I"'9<p>在逛 programcreek 的时候，我发现了一些小而精悍的主题。比如说：Java 的 <code class="highlighter-rouge">substring()</code> 方法是如何工作的？像这类灵魂拷问的主题，非常值得深入地研究一下。</p>

<!--more-->

<p>另外，我想要告诉大家的是，研究的过程非常的有趣，就好像在迷宫里探宝一样，起初有些不知所措，但经过一番用心的摸索后，不但会找到宝藏，还会有一种茅塞顿开的感觉，非常棒。</p>

<p>对于绝大多数的初级程序员或者说不重视“内功”的老鸟来说，往往停留在“知其然不知其所以然”的层面上——会用，但要说底层的原理，可就只能挠挠头双手一摊一张问号脸了。</p>

<p>很长一段时间内，<a href="https://mp.weixin.qq.com/s/feoOINGSyivBO8Z1gaQVOA">我</a>也一直处于这种层面上。但我决定改变了，因为“内功”就好像是在打地基，只有把地基打好了，才能盖起经得住考验的高楼大厦。借此机会，我就和大家一起，对“Java 的 substring() 是如何工作的”进行一次深入地研究。注意了，准备打怪升级了！</p>

<h3 id="01substring-是干嘛的">01、substring() 是干嘛的</h3>

<p><code class="highlighter-rouge">sub</code> 是 <code class="highlighter-rouge">subtract</code> 的缩写，因此 <code class="highlighter-rouge">substring</code> 的字面意思就是“把字符串做个减法”。这样一分析，是不是感觉方法的命名还是蛮有讲究的？</p>

<p><code class="highlighter-rouge">substring()</code> 的完整写法是 <code class="highlighter-rouge">substring(int beginIndex, int endIndex)</code>。该方法返回一个新的字符串，介于原有字符串的起始下标 <code class="highlighter-rouge">beginIndex</code> 和结尾下标 <code class="highlighter-rouge">endIndex-1</code> 之间。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">cmower</span> <span class="o">=</span> <span class="s">"沉默王二，一枚有趣的程序员"</span><span class="o">;</span>
<span class="n">cmower</span> <span class="o">=</span> <span class="n">cmower</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">4</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">cmower</span><span class="o">);</span>
</code></pre></div></div>

<p>程序输出的结果为：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>沉默王二
</code></pre></div></div>

<p>为什么呢？我来简单解释一下。</p>

<p>Java 的下标都是从 0 开始编号的（我不确定有没有从 1 开始的编程语言），这和我们平常生活中从 1 开始编号的习惯不同。Java 这样做的原因如下：</p>

<p>Java 是基于 C 语言实现的，而 C 语言的下标是从 0 开始的——这听起来好像是一句废话。真正的原因是下标并不是下标，在指针（C）语言中，它实际上是一个偏移量，距离开始位置的一个偏移量。第一个元素在开头，因此它的偏移量就为 0。</p>

<p>此外，还有另外一种说法。早期的计算机资源比较匮乏，0 作为起始下标相比较于 1 作为起始下标，编译的效率更高。</p>

<p>知道了这层原因后，再来看上面这段代码，就会豁然开朗。对于“沉默王二，一枚有趣的程序员”这串字符来说，“沉”的下标为 0，“默”的下标为 1，“王”的下标为 2，“二”的下标为 3，所以 <code class="highlighter-rouge">cmower.substring(0, 4)</code> 返回的字符串是“沉默王二”——包括起始下标但不包括结尾下标。</p>

<h3 id="02substring-在被调用的时候究竟发生了什么">02、substring() 在被调用的时候究竟发生了什么？</h3>

<p>在此之前，我们已经了解到：<a href="">字符串是不可变的</a>，因此当调用 <code class="highlighter-rouge">substring()</code> 方法的时候，返回的其实是一个新的字符串。那么变量 cmower 的地址引用就会发生如下图所示的变化。</p>

<p><img src="http://www.itwanger.com/assets/images/2019/12/java-substring-2.png" alt="" /></p>

<p>为了证明上图是完全正确的，我们来看一下 JDK 7 中 <code class="highlighter-rouge">substring()</code> 的源码。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nf">String</span><span class="o">(</span><span class="kt">char</span> <span class="n">value</span><span class="o">[],</span> <span class="kt">int</span> <span class="n">offset</span><span class="o">,</span> <span class="kt">int</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>
	<span class="c1">//check boundary</span>
	<span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOfRange</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">offset</span><span class="o">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">count</span><span class="o">);</span>
<span class="o">}</span>
 
<span class="kd">public</span> <span class="nc">String</span> <span class="nf">substring</span><span class="o">(</span><span class="kt">int</span> <span class="n">beginIndex</span><span class="o">,</span> <span class="kt">int</span> <span class="n">endIndex</span><span class="o">)</span> <span class="o">{</span>
	<span class="c1">//check boundary</span>
	<span class="kt">int</span> <span class="n">subLen</span> <span class="o">=</span> <span class="n">endIndex</span> <span class="o">-</span> <span class="n">beginIndex</span><span class="o">;</span>
	<span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">beginIndex</span><span class="o">,</span> <span class="n">subLen</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>可以看得出，<code class="highlighter-rouge">substring()</code> 通过 <code class="highlighter-rouge">new String()</code> 返回了一个新的字符串对象，在创建新的对象时通过 <code class="highlighter-rouge">Arrays.copyOfRange()</code> 复制了一个新的字符数组。</p>

<p>但 JDK 6 就有所不同。说到 JDK 6，可能有些读者表示不服，JDK 6？什么年代了，JDK 13 都出来了好不好？但我想告诉大家的是，对比着剖析 JDK 的源码，对学习大有裨益。</p>

<p>不是有那么一句话嘛，要想了解一个成功人士，不能只关注他发迹以后的事，更要关注他之前做了什么。</p>

<p>就请随我来，看看 JDK 6 中的 <code class="highlighter-rouge">substring()</code> 的源码吧。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//JDK 6</span>
<span class="nc">String</span><span class="o">(</span><span class="kt">int</span> <span class="n">offset</span><span class="o">,</span> <span class="kt">int</span> <span class="n">count</span><span class="o">,</span> <span class="kt">char</span> <span class="n">value</span><span class="o">[])</span> <span class="o">{</span>
	<span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
	<span class="k">this</span><span class="o">.</span><span class="na">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="o">;</span>
	<span class="k">this</span><span class="o">.</span><span class="na">count</span> <span class="o">=</span> <span class="n">count</span><span class="o">;</span>
<span class="o">}</span>
 
<span class="kd">public</span> <span class="nc">String</span> <span class="nf">substring</span><span class="o">(</span><span class="kt">int</span> <span class="n">beginIndex</span><span class="o">,</span> <span class="kt">int</span> <span class="n">endIndex</span><span class="o">)</span> <span class="o">{</span>
	<span class="c1">//check boundary</span>
	<span class="k">return</span>  <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">beginIndex</span><span class="o">,</span> <span class="n">endIndex</span> <span class="o">-</span> <span class="n">beginIndex</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">substring()</code> 方法本身和 JDK 7 并没有很大的差别，都通过 <code class="highlighter-rouge">new String()</code> 返回了一个新的字符串对象。但是 <code class="highlighter-rouge">String()</code> 这个构造函数有很大的差别，JDK 6 只是简单地更改了一下两个属性（<code class="highlighter-rouge">offset</code> 和 <code class="highlighter-rouge">count</code>）的值，value 并没有变。</p>

<p>PS：<code class="highlighter-rouge">value</code> 是真正存储字符的数组，<code class="highlighter-rouge">offset</code> 是数组中第一个元素的下标，<code class="highlighter-rouge">count</code> 是数组中字符的个数。</p>

<p>这意味着什么呢？</p>

<p>调用 <code class="highlighter-rouge">substring()</code> 的时候虽然创建了新的字符串，但字符串的值仍然指向的是内存中的同一个数组，如下图所示。</p>

<p><img src="http://www.itwanger.com/assets/images/2019/12/java-substring-3.png" alt="" /></p>

<h3 id="03为什么-jdk-7-的构造函数发生了变化">03、为什么 JDK 7 的构造函数发生了变化</h3>

<p>看了 JDK 6 和 JDK 7 源码之后，大家可能产生这样一个疑惑：为什么 JDK 7 要做出改变呢？大家共用同一个字符串数组不是挺好的嘛，省得占用新的内存空间。事实上呢？</p>

<p>如果有一个很长很长的字符串，可以绕地球一周，当我们需要调用 <code class="highlighter-rouge">substring()</code> 截取其中很小一段字符串时，就有可能导致性能问题。由于这一小段字符串引用了整个很长很长的字符数组，就导致很长很长的这个字符数组无法被回收，内存一直被占用着，就有可能引发内存泄露。</p>

<p>PS：内存泄露是指由于疏忽或错误造成程序未能释放已经不再使用的内存。</p>

<p>那 JDK 7 出现之前，这个隐患怎么应对呢？答案如下。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cmower</span> <span class="o">=</span> <span class="n">cmower</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span> <span class="o">+</span> <span class="s">""</span><span class="o">;</span>
</code></pre></div></div>

<p>为什么，为什么，为什么，多一个 “+ ““” 就能解决内存泄漏的问题？有些读者可能不太相信，我来带大家分析一下。</p>

<p>首先呢，我们通过 <a href="http://www.itwanger.com/java/2019/10/22/javac-jad.html">JAD</a> 对字节码反编译一下，上面这行代码就变成了如下内容。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">cmower</span> <span class="o">=</span> <span class="o">(</span><span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">cmower</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">4</span><span class="o">)))).</span><span class="na">toString</span><span class="o">();</span>
</code></pre></div></div>

<p>“+”号操作符就相当于一个语法糖，加上空的字符串后，会被 JDK 转化为 StringBuilder 对象，该对象在处理字符串的时候会生成新的字符数组，所以 <code class="highlighter-rouge">cmower = cmower.substring(0, 4) + "";</code> 这行代码执行后，cmower 就指向了和 <code class="highlighter-rouge">substring()</code> 调用之前不同的字符数组。</p>

<p>PS：如果不明白“+”号操作符的工作原理，请查阅我之前写的文章《<a href="https://mp.weixin.qq.com/s/doWGxF94sd6V_dSwJMmE-Q">羞，Java 字符串拼接竟然有这么多姿势</a>》，这里就不再赘述，免得被老读者捶。</p>

<h3 id="04最后">04、最后</h3>

<p>总结一下，JDK 7 和 JDK 6 的 <code class="highlighter-rouge">substring()</code> 方法本身并没有多大的改变，但 String 类的构造函数有了很大的区别，JDK 7 会重新复制一份字符数组，而 JDK 6 不会，因此 JDK 6 在执行比较长的字符串 <code class="highlighter-rouge">substring()</code> 时可能会引发内存泄露的问题。</p>

<hr />

<p>好了各位读者朋友们，以上就是本文的全部内容了。<strong>能看到这里的都是最优秀的程序员，二哥必须要为你点个赞</strong>👍。如果觉得不过瘾，还想看到更多，我再推荐几篇给大家。</p>

<p><a href="http://www.itwanger.com/java/2019/11/28/java-string-shuangyinhao-gouzaohanshu.html">灵魂拷问：创建 Java 字符串，用”“还是构造函数</a></p>

<p><a href="https://mp.weixin.qq.com/s/CRQrm5zGpqWxYL_ztk-b2Q">灵魂拷问：为什么 Java 字符串是不可变的？</a></p>

<p><a href="https://mp.weixin.qq.com/s/DBvgghP5cN6KlPnILaqjmQ">灵魂拷问：如何检查Java数组中是否包含某个值 ？</a></p>

<p>如果觉得这篇文章有点用的话，<strong>求点赞、求留言、求关注</strong>，咱们一起养成好习惯！另外，我整理了一份顶级 Java 程序员必读的书单，回台回复关键字「Java」即可免费获取。</p>
:ET