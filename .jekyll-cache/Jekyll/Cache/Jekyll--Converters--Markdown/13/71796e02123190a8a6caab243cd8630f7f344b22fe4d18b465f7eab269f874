I"d<p><a href="https://mp.weixin.qq.com/s/feoOINGSyivBO8Z1gaQVOA">我</a>从事Java编程已经11年了，绝对是个老兵；但对于Java并发编程，我只能算是个新兵蛋子。我说这话估计要遭到某些高手的冷嘲热讽，但我并不感到害怕。</p>

<p>因为我知道，每年都会有很多很多的新人要加入Java编程的大军，他们对“并发”编程中遇到的问题也会有感到无助的时候。而我，非常乐意与他们一道，对使用Java线程进行并发程序开发的基础知识进行新一轮的学习。</p>

<!--more-->

<h3 id="01我们为什么要学习并发">01、我们为什么要学习并发？</h3>

<p>我的脑袋没有被如来佛祖开过光，所以喜欢一件事接着一件事的想，做不到“一脑两用”。但有些大佬就不一样，比如说诸葛亮，就能够一边想着琴谱一边谈着弹着琴，还能夹带着盘算出司马懿退兵后的打算。</p>

<p>诸葛大佬就有着超强的“并发”能力啊。换做是我，面对司马懿的千万大军，不仅弹不了琴，弄不好还被吓得屁滚尿流。</p>

<p>每个人都只有一个脑子，就像电脑只有一个CPU一样。但一个脑子并不意味着不能“一脑两用”，关键就在于脑子有没有“并发”的能力。</p>

<p>脑子要是有了并发能力，那真的是厉害到飞起啊，想想司马懿被气定神闲的诸葛大佬吓跑的样子就知道了。</p>

<p>对于程序来说，如果具有并发的能力，效率就能够大幅度地提升。你一定注册过不少网站，收到过不少验证码，如果网站的服务器端在发送验证码的时候，没有专门起一个线程来处理（并发），假如网络不好发生阻塞的话，那服务器端岂不是要从天亮等到天黑才知道你有没有收到验证码？如果就你一个用户也就算了，但假如有一百个用户呢？这一百个用户难道也要在那傻傻地等着，那真要等到花都谢了。</p>

<p>可想而知，并发编程是多么的重要！况且，懂不懂Java虚拟机和会不会并发编程，几乎是判定一个Java开发人员是不是高手的不三法则。所以<strong>要想挣得多，还得会并发啊</strong>！</p>

<h3 id="02并发第一步创建一个线程">02、并发第一步，创建一个线程</h3>

<p>通常，启动一个程序，就相当于起了一个进程。每个电脑都会运行很多程序，所以你会在进程管理器中看到很多进程。你会说，这不废话吗？</p>

<p>不不不，在我刚学习编程的很长一段时间内，我都想当然地以为这些进程就是线程；但后来我知道不是那么回事儿。一个进程里，可能会有很多线程在运行，也可能只有一个。</p>

<p>main函数其实就是一个主线程。我们可以在这个主线程当中创建很多其他的线程。来看下面这段代码。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Wanger</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>
				
				<span class="nd">@Override</span>
				<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
					<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"我叫"</span> <span class="o">+</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">"，我超喜欢沉默王二的写作风格"</span><span class="o">);</span>
				<span class="o">}</span>
			<span class="o">});</span>
			<span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>创建线程最常用的方式就是声明一个实现了<code class="highlighter-rouge">Runnable</code>接口的匿名内部类；然后将它作为创建<code class="highlighter-rouge">Thread</code>对象的参数；再然后调用<code class="highlighter-rouge">Thread</code>对象的<code class="highlighter-rouge">start()</code>方法进行启动。运行的结果如下。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">我叫Thread</span><span class="o">-</span><span class="mi">1</span><span class="err">，</span><span class="n">我超喜欢沉默王二的写作风格</span>
<span class="n">我叫Thread</span><span class="o">-</span><span class="mi">3</span><span class="err">，</span><span class="n">我超喜欢沉默王二的写作风格</span>
<span class="n">我叫Thread</span><span class="o">-</span><span class="mi">2</span><span class="err">，</span><span class="n">我超喜欢沉默王二的写作风格</span>
<span class="n">我叫Thread</span><span class="o">-</span><span class="mi">0</span><span class="err">，</span><span class="n">我超喜欢沉默王二的写作风格</span>
<span class="n">我叫Thread</span><span class="o">-</span><span class="mi">5</span><span class="err">，</span><span class="n">我超喜欢沉默王二的写作风格</span>
<span class="n">我叫Thread</span><span class="o">-</span><span class="mi">4</span><span class="err">，</span><span class="n">我超喜欢沉默王二的写作风格</span>
<span class="n">我叫Thread</span><span class="o">-</span><span class="mi">6</span><span class="err">，</span><span class="n">我超喜欢沉默王二的写作风格</span>
<span class="n">我叫Thread</span><span class="o">-</span><span class="mi">7</span><span class="err">，</span><span class="n">我超喜欢沉默王二的写作风格</span>
<span class="n">我叫Thread</span><span class="o">-</span><span class="mi">8</span><span class="err">，</span><span class="n">我超喜欢沉默王二的写作风格</span>
<span class="n">我叫Thread</span><span class="o">-</span><span class="mi">9</span><span class="err">，</span><span class="n">我超喜欢沉默王二的写作风格</span>
</code></pre></div></div>

<p>从运行的结果中可以看得出来，线程的执行顺序不是从0到9的，而是有一定的随机性。这是因为Java的并发是抢占式的，<strong>线程0虽然创建得最早，但它的“争宠”能力却一般，上位得比较艰辛</strong>。</p>

<h3 id="03并发第二步创建线程池">03、并发第二步，创建线程池</h3>

<p><code class="highlighter-rouge">java.util.concurrent.Executors</code>类提供了一系列工厂方法用于创建线程池，可把多个线程放在一起进行更高效地管理。示例如下。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Wanger</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">ExecutorService</span> <span class="n">executorService</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newCachedThreadPool</span><span class="o">();</span>

		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="nc">Runnable</span> <span class="n">r</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>

				<span class="nd">@Override</span>
				<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
					<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"我叫"</span> <span class="o">+</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">"，我超喜欢沉默王二的写作风格"</span><span class="o">);</span>
				<span class="o">}</span>
			<span class="o">};</span>
			<span class="n">executorService</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">r</span><span class="o">);</span>
		<span class="o">}</span>
		<span class="n">executorService</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>运行的结果如下。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">我叫pool</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">thread</span><span class="o">-</span><span class="mi">2</span><span class="err">，</span><span class="n">我超喜欢沉默王二的写作风格</span>
<span class="n">我叫pool</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">thread</span><span class="o">-</span><span class="mi">4</span><span class="err">，</span><span class="n">我超喜欢沉默王二的写作风格</span>
<span class="n">我叫pool</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">thread</span><span class="o">-</span><span class="mi">5</span><span class="err">，</span><span class="n">我超喜欢沉默王二的写作风格</span>
<span class="n">我叫pool</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">thread</span><span class="o">-</span><span class="mi">3</span><span class="err">，</span><span class="n">我超喜欢沉默王二的写作风格</span>
<span class="n">我叫pool</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">thread</span><span class="o">-</span><span class="mi">4</span><span class="err">，</span><span class="n">我超喜欢沉默王二的写作风格</span>
<span class="n">我叫pool</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">thread</span><span class="o">-</span><span class="mi">1</span><span class="err">，</span><span class="n">我超喜欢沉默王二的写作风格</span>
<span class="n">我叫pool</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">thread</span><span class="o">-</span><span class="mi">7</span><span class="err">，</span><span class="n">我超喜欢沉默王二的写作风格</span>
<span class="n">我叫pool</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">thread</span><span class="o">-</span><span class="mi">6</span><span class="err">，</span><span class="n">我超喜欢沉默王二的写作风格</span>
<span class="n">我叫pool</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">thread</span><span class="o">-</span><span class="mi">5</span><span class="err">，</span><span class="n">我超喜欢沉默王二的写作风格</span>
<span class="n">我叫pool</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">thread</span><span class="o">-</span><span class="mi">6</span><span class="err">，</span><span class="n">我超喜欢沉默王二的写作风格</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Executors</code>的<code class="highlighter-rouge">newCachedThreadPool()</code>方法用于创建一个可缓存的线程池，调用该线程池的方法<code class="highlighter-rouge">execute()</code>可以重用以前的线程，只要该线程可用；比如说，<code class="highlighter-rouge">pool-1-thread-4</code>、<code class="highlighter-rouge">pool-1-thread-5</code>和<code class="highlighter-rouge">pool-1-thread-6</code>就得到了重用的机会。我能想到的最佳形象代言人就是女皇武则天。</p>

<p>如果没有可用的线程，就会创建一个新线程并添加到池中。当然了，那些60秒内还没有被使用的线程也会从缓存中移除。</p>

<p>另外，<code class="highlighter-rouge">Executors</code>的<code class="highlighter-rouge">newFiexedThreadPool(int num)</code>方法用于创建固定数目线程的线程池；<code class="highlighter-rouge">newSingleThreadExecutor()</code>方法用于创建单线程化的线程池（你能想到它应该使用的场合吗？）。</p>

<p>但是，故事要转折了。阿里巴巴的Java开发手册（可在「沉默王二」公众号的后台回复关键字「Java」获取）中明确地指出，<strong>不允许</strong>使用Executors来创建线程池。</p>

<p><img src="http://www.itwanger.com/assets/images/2019/11/java-bingfa-1.png" alt="" /></p>

<p>不能使用<code class="highlighter-rouge">Executors</code>创建线程池，那么该怎么创建线程池呢？</p>

<p>直接调用<code class="highlighter-rouge">ThreadPoolExecutor</code>的构造函数来创建线程池呗。其实<code class="highlighter-rouge">Executors</code>就是这么做的，只不过没有对<code class="highlighter-rouge">BlockQueue</code>指定容量。我们需要做的就是在创建的时候指定容量。代码示例如下。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ExecutorService</span> <span class="n">executor</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadPoolExecutor</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span>
        <span class="mi">60L</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">,</span>
        <span class="k">new</span> <span class="nf">ArrayBlockingQueue</span><span class="o">(</span><span class="mi">10</span><span class="o">));</span>
</code></pre></div></div>

<h3 id="04并发第三步解决共享资源竞争的问题">04、并发第三步，解决共享资源竞争的问题</h3>

<p>有一次，我陪家人在商场里面逛街，出电梯的时候有一个傻叉非要抢着进电梯。女儿的小推车就压到了那傻叉的脚上，他竟然不依不饶地指着我的鼻子叫嚣。我直接一拳就打在他的鼻子上，随后我们就纠缠在了一起。</p>

<p>这件事情说明了什么问题呢？第一，遇到不讲文明不知道“先出后进”（LIFO）规则的傻叉真的很麻烦；第二，竞争共享资源的时候，弄不好要拳脚相向。</p>

<p>在Java中，解决共享资源竞争问题的首个解决方案就是使用关键字<code class="highlighter-rouge">synchronized</code>。当线程执行被<code class="highlighter-rouge">synchronized</code>保护的代码片段的时候，会对这段代码进行上锁，其他调用这段代码的线程会被阻塞，直到锁被释放。</p>

<p>下面这段代码使用<code class="highlighter-rouge">ThreadPoolExecutor</code>创建了一个线程池，池里面的每个线程会对共享资源count进行+1操作。现在，闭上眼想一想，当1000个线程执行结束后，count的值会是多少呢？</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Wanger</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">getCount</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">count</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">addCount</span><span class="o">()</span> <span class="o">{</span>
		 <span class="n">count</span><span class="o">++;</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">ExecutorService</span> <span class="n">executorService</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadPoolExecutor</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">1000</span><span class="o">,</span>
		        <span class="mi">60L</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">,</span>
		        <span class="k">new</span> <span class="nc">ArrayBlockingQueue</span><span class="o">&lt;</span><span class="nc">Runnable</span><span class="o">&gt;(</span><span class="mi">10</span><span class="o">));</span>


		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="nc">Runnable</span> <span class="n">r</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>

				<span class="nd">@Override</span>
				<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
					<span class="nc">Wanger</span><span class="o">.</span><span class="na">addCount</span><span class="o">();</span>
				<span class="o">}</span>
			<span class="o">};</span>
			<span class="n">executorService</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">r</span><span class="o">);</span>
		<span class="o">}</span>
		<span class="n">executorService</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Wanger</span><span class="o">.</span><span class="na">count</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>事实上，共享资源count的值很有可能是996、998，但很少会是1000。为什么呢？</p>

<p>因为一个线程正在写这个变量的时候，另外一个线程可能正在读这个变量，或者正在写这个变量。这个变量就变成了一个“不确定状态”的数据。<strong>这个变量必须被保护起来</strong>。</p>

<p>通常的做法就是在改变这个变量的<code class="highlighter-rouge">addCount()</code>方法上加上<code class="highlighter-rouge">synchronized</code>关键字——保证线程在访问这个变量的时候有序地进行排队。</p>

<p>示例如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">synchronized</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">addCount</span><span class="o">()</span> <span class="o">{</span>
	 <span class="n">count</span><span class="o">++;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>还有另外的一种常用方法——读写锁。分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，由Java虚拟机控制。如果代码允许很多线程同时读，但不能同时写，就上读锁；如果代码不允许同时读，并且只能有一个线程在写，就上写锁。</p>

<p>读写锁的接口是<code class="highlighter-rouge">ReadWriteLock</code>，具体实现类是 <code class="highlighter-rouge">ReentrantReadWriteLock</code>。<code class="highlighter-rouge">synchronized</code>属于互斥锁，任何时候只允许一个线程的读写操作，其他线程必须等待；而<code class="highlighter-rouge">ReadWriteLock</code>允许多个线程获得读锁，但只允许一个线程获得写锁，效率相对较高一些。</p>

<p>我们先使用枚举创建一个读写锁的单例。代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="nc">Locker</span> <span class="o">{</span>

	<span class="no">INSTANCE</span><span class="o">;</span>

	<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">ReadWriteLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ReentrantReadWriteLock</span><span class="o">();</span>

	<span class="kd">public</span> <span class="nc">Lock</span> <span class="nf">writeLock</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">lock</span><span class="o">.</span><span class="na">writeLock</span><span class="o">();</span>
	<span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>再在<code class="highlighter-rouge">addCount()</code>方法中对<code class="highlighter-rouge">count++;</code>上锁。示例如下。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">addCount</span><span class="o">()</span> <span class="o">{</span>
	<span class="c1">// 上锁</span>
	<span class="nc">Lock</span> <span class="n">writeLock</span> <span class="o">=</span> <span class="nc">Locker</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">.</span><span class="na">writeLock</span><span class="o">();</span>
	<span class="n">writeLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
	<span class="n">count</span><span class="o">++;</span>
	<span class="c1">// 释放锁</span>
	<span class="n">writeLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>使用读写锁的时候，切记最后要释放锁。</p>

<h3 id="05最后">05、最后</h3>

<p>并发编程难学吗？说实话，真的不太容易。来看一下王宝令老师总结的思维导图就能知道。</p>

<p><img src="http://www.itwanger.com/assets/images/2019/11/java-bingfa-2.png" alt="" /></p>

<p>但你也知道，“<strong>冰冻三尺非一日之寒</strong>”，学习是一件循序渐进的事情。只要你学会了怎么创建一个线程，学会了怎么创建线程池，学会了怎么解决共享资源竞争的问题，你已经在并发编程的领域里迈出去了一大步。</p>

<hr />

<p>上一篇：<a href="http://www.itwanger.com/java/2019/11/09/java-io.html">Java I/O 入门篇</a></p>

<p>下一篇：<a href="http://www.itwanger.com/java/2019/11/09/java-bingfa-1.html">Java 并发编程(一)：简介</a></p>

<p>微信搜索「<strong>沉默王二</strong>」公众号，关注后回复「<strong>免费视频</strong>」获取 500G 高质量教学视频（<a href="https://mp.weixin.qq.com/s/GjkEyPW0vgIvuDLYQkBM0A">已分门别类</a>）。</p>

:ET