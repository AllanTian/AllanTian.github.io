I"tZ<blockquote>
  <p>二哥，究竟什么是面向对象呢？还有，什么是面向过程。今天去面试的时候，面试官让我用面向对象的思想谈一谈这次面试的过程。</p>
</blockquote>

<!--more-->

<p>前两天，读者秋秋问我了我上面这个问题。</p>

<p>看到这个问题后，我思考了好一会儿，总觉得面试官的问法有点问题：为什么要用面向对象的思想谈一谈面试的“过程”？</p>

<p>有点矛盾，有没有？先不管这么多了，且来看看什么是<a href="http://www.itwanger.com/java/2019/11/01/oop.html">面向对象</a>吧。</p>

<h3 id="01面向对象">01、面向对象</h3>

<p>很久没有思考过什么是面向对象这个问题了，就好像很久没有吃过烤红薯一样，那股香味究竟是什么，已经很难准确地形容出来了。脑海中只浮现出这样一幅图：</p>

<p><img src="http://www.itwanger.com/assets/images/2019/11/java-oo-po-1.gif" alt="" /></p>

<p>一开始的时候，并没有面向对象，只有面向过程的概念。我们回到秋秋面试的话题上，把面试前（可以降低需求的复杂性）的过程简单地拆解一下。</p>

<ul>
  <li>秋秋投递简历</li>
  <li>面试官收到秋秋的简历</li>
  <li>面试官通知秋秋面试</li>
</ul>

<p>为了实现这 3 个步骤，我们定义 3 个方法，并依次调用：</p>

<ul>
  <li>qiuqiuDeliverResume();</li>
  <li>interviewerReceiveResume();</li>
  <li>interviewerNotifyQiuqiu();</li>
</ul>

<p>但是，假如参加面试的不是秋秋，这 3 个方法就要重新定义了（莫抬杠），尽管步骤并没有变。面向对象从另一个角度来解决这个问题，它把对象（对事物的一种抽象描述）作为程序的基本单元。</p>

<p>回到秋秋面试的例子，用面向对象的思想来实现，就需要先定义 2 个类（类是构建对象的蓝图，里面包含若干的数据和操作这些数据的方法），分别是应聘者和面试官。</p>

<p>应聘者可以投递简历；面试官可以接收应聘者的简历和通知应聘者前来面试。然后再通过类创建两个对象，分别是秋秋和他的面试官；对象创建成功后，就可以依次调用对应的方法完成上述的 3 个步骤。</p>

<p>面向对象（英语：Object Oriented，缩写：OO）思想是一种试图降低代码间的依赖，应对复杂性，从而解决代码重用的软件设计思想——恰好解决了面向过程带来的问题。</p>

<p>面向对象有很多重要的特性，比如说封装、继承和多态。这些概念又该怎么理解呢？所谓一图胜千言，我给你来一张有趣的、形象的。</p>

<p><img src="http://www.itwanger.com/assets/images/2019/11/java-oo-po-2.jpg" alt="" /></p>

<p>了解了面向对象的思想后，我们来通过具体的代码完成秋秋面试前的 3 个步骤。并对类和对象的相关知识点进行归纳和总结。</p>

<h3 id="02应聘者">02、应聘者</h3>

<p>先来细致地看一下应聘者类——Candidate.java。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.cmower</span>

<span class="kd">class</span> <span class="nc">Candidate</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
	
	<span class="kd">public</span> <span class="nf">Candidate</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">deliverResume</span><span class="o">()</span> <span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">"发简历"</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">name</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
	<span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>Candidate 包含了类的 4 个重要概念：</p>

<ul>
  <li>成员变量（有时叫做域，有时叫做字段，有时叫做属性）<code class="highlighter-rouge">name</code>；</li>
  <li>成员变量访问器（有时叫做 <code class="highlighter-rouge">getter/setter </code>）<code class="highlighter-rouge">getName()</code> 和 <code class="highlighter-rouge">setName()</code>；</li>
  <li>构造方法（有时叫做构造器）<code class="highlighter-rouge">Candidate()</code>；</li>
  <li>普通方法 <code class="highlighter-rouge">deliverResume()</code>。</li>
</ul>

<p>Candidate 类虽然简单，但却大有学问。</p>

<p>1）为了保证包名的绝对唯一，Sun 公司建议将域名（绝对是独一无二的）以逆序的形式作为包名——这也是为什么包名经常以 <code class="highlighter-rouge">org</code>、<code class="highlighter-rouge">com</code> 开头的原因（是不是有一种豁然开朗的感觉）。我曾申请过一个域名，叫 cmower.com，所以我个人编写的绝大多数代码都是在 <code class="highlighter-rouge">com.cmower</code>包下。</p>

<p>2）类的方法定义顺序依次是：构造方法 &gt; 公有（<code class="highlighter-rouge">public</code>）方法或保护（<code class="highlighter-rouge">protected</code>）方法 &gt; 私有（<code class="highlighter-rouge">private</code>）方法 &gt; getter/setter 方法。</p>

<p>构造方法是创建对象的必经之路，放在首位是必须的。如果只有系统默认的无参构造方法，可忽略。</p>

<p>公有方法是类的调用者和维护者最关心的方法，应该在比较靠前的位置展示；保护方法虽然只有子类关心，也可能是“模板设计模式”下的核心方法，所以也要靠前；私有方法只对本类可见，一般不需要特别关心，所以往后放；<code class="highlighter-rouge">getter/setter</code> 方法承载的信息价值较低，所以放在类的最后面。</p>

<p>3）setter 方法中，参数名称与成员变量名称保持一致，采用 <code class="highlighter-rouge">this.成员名 = 参数名</code> 的形式。</p>

<p>4）成员变量不要用 <code class="highlighter-rouge">public</code> 修饰，尽量用 <code class="highlighter-rouge">private</code> 修饰；如果需要被子类继承，可以用 <code class="highlighter-rouge">protected</code> 修饰。</p>

<p>在初学 Java 编程的时候，我经常产生一个疑惑：为什么不使用  <code class="highlighter-rouge">public</code> 修饰成员变量呢？这样做不是比 <code class="highlighter-rouge">getter/setter</code> 更方便吗？</p>

<p>我最先想到的答案是这样的：</p>

<p><img src="http://www.itwanger.com/assets/images/2019/11/java-oo-po-3.png" alt="" /></p>

<p><em>解释</em>：如果只有 <code class="highlighter-rouge">private String name</code> 而没有 <code class="highlighter-rouge">getter/setter</code> 的话，Eclipse 会提示 <code class="highlighter-rouge">The value of the field Candidate.name is not used</code> 的警告。</p>

<p>当然了，这样的答案过于牵强。那能不能来个靠谱点的答案呢？</p>

<p>能，为了体现封装的思想：将数据与行为进行分离。封装有什么好处呢？</p>

<ul>
  <li>隐藏类的实现细节；</li>
  <li>让使用者只能通过事先定制好的方法（<code class="highlighter-rouge">getter/setter</code>）来访问数据，可以方便地加入控制方法，限制对成员变量的不合理操作；</li>
  <li>便于修改，增强代码的维护性和健壮性；</li>
  <li>提高代码的安全性和规范性；</li>
  <li>使程序更加具备稳定性和可拓展性。</li>
</ul>

<p>不过，我对这些严肃的词汇和科学用语实在是提不起半点兴致。那就再换一个答案吧。</p>

<p>套用《Java 开发实战经典》中举过的一个例子，我们增加一个应聘者年龄的共有成员变量 age。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Candidate</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>然后在创建应聘者对象的时候，直接通过类成员变量赋值：<code class="highlighter-rouge">new Candidate().age = -99;</code> 这样赋值是没有任何问题的，但没有实际的意义，年龄是不可能为负数的。为了防止出现这样的错误，可以对它进行封装，也就是私有化，然后在 <code class="highlighter-rouge">setter</code> 方法中对年龄进行判断，代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Candidate</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setAge</span><span class="o">(</span><span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">age</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
      <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这个答案你觉得满意吗？我最开始看到这个答案的时候觉得很满意。但看了《阿里巴巴 Java 开发手册》后（详情截图如下），就觉得不满意了。</p>

<p><img src="http://www.itwanger.com/assets/images/2019/11/java-oo-po-4.png" alt="" /></p>

<p>第一，类成员变量使用基本类型很容易造成<code class="highlighter-rouge">NullPointException</code>的错误；第二，在 <code class="highlighter-rouge">getter/setter</code> 增加业务逻辑的确很容易把实际的问题隐藏起来。</p>

<p>那，好的答案究竟是什么呢？</p>

<p>如果设置成员变量为 <code class="highlighter-rouge">public</code>，那么每个调用者都可以读写它，但如果以 <code class="highlighter-rouge">private</code> 配合 <code class="highlighter-rouge">getter/setter</code> 的形式访问时，就可以达到“不准访问”、“只读访问”、“读写访问”以及“只写访问”的目的。因为不是每个成员变量都需要 <code class="highlighter-rouge">getter/setter</code>。</p>

<p>5）每个类都至少会有一个构造方法。初学者可能会非常疑惑：我的那个类真的没有构造方法啊！</p>

<p>如果在编写一个类的时候没有编写构造方法，那么系统就会提供一个无参的构造方法，就好像是这样：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Candidate</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
	
	<span class="kd">public</span> <span class="nf">Candidate</span><span class="o">()</span> <span class="o">{</span>
	<span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>当执行 <code class="highlighter-rouge">new Candidate()</code> 的时候，成员变量 name 就会被初始化为 <code class="highlighter-rouge">null</code>。一般情况下，我们会为类设置它必须的构造方法，然后在创建对象的时候对成员变量进行赋值。</p>

<h3 id="03面试官">03、面试官</h3>

<p>再来粗略地看一下面试官类——Interviewer.java。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Interviewer</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="nc">Candidate</span> <span class="n">candidate</span><span class="o">;</span>
	
	<span class="kd">public</span> <span class="nf">Interviewer</span> <span class="o">(</span><span class="nc">Candidate</span> <span class="n">candidate</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">candidate</span> <span class="o">=</span> <span class="n">candidate</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">receviveResume</span><span class="o">()</span> <span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"收到"</span> <span class="o">+</span> <span class="n">getCandidate</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">"简历"</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">notifyInterview</span><span class="o">()</span> <span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"通知"</span> <span class="o">+</span> <span class="n">getCandidate</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">"面试"</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="nc">Candidate</span> <span class="nf">getCandidate</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">candidate</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setCandidate</span><span class="o">(</span><span class="nc">Candidate</span> <span class="n">candidate</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">candidate</span> <span class="o">=</span> <span class="n">candidate</span><span class="o">;</span>
	<span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>Interviewer 有一个成员变量 Candidate，一个构造方法，两个共有方法，以及成员变量对应的 <code class="highlighter-rouge">getter/setter</code>。</p>

<p><em>（这段代码存在一个严重的问题，你注意到了吗？）</em></p>

<h3 id="04测试">04、测试</h3>

<p>然后，我们让应聘者发送简历，让面试官接收简历并发送通知。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Candidate</span> <span class="n">qiuqiu</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Candidate</span><span class="o">(</span><span class="s">"秋秋"</span><span class="o">);</span>
<span class="c1">// 发送简历</span>
<span class="n">qiuqiu</span><span class="o">.</span><span class="na">deliverResume</span><span class="o">();</span>

<span class="nc">Interviewer</span> <span class="n">interviewer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Interviewer</span><span class="o">(</span><span class="n">qiuqiu</span><span class="o">);</span>
<span class="c1">// 面试官接收到简历</span>
<span class="n">interviewer</span><span class="o">.</span><span class="na">receviveResume</span><span class="o">();</span>
<span class="c1">// 面试官通知应聘者来面试</span>
<span class="n">interviewer</span><span class="o">.</span><span class="na">notifyInterview</span><span class="o">();</span>
</code></pre></div></div>

<p>在初学 Java 的很长一段时间里，我总是搞不清楚什么是“对象”，什么是“引用”，差点因此放弃我的程序生涯。后来，在网上认识了一个大佬，人称老王，是他挽救了我的程序生涯。</p>

<p>他解释说。</p>

<p><code class="highlighter-rouge">Candidate qiuqiu = new Candidate("秋秋");</code> 可以拆分为两行代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Candidate</span> <span class="n">qiuqiu</span><span class="o">;</span>
<span class="n">qiuqiu</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Candidate</span><span class="o">(</span><span class="s">"秋秋"</span><span class="o">);</span>
</code></pre></div></div>

<p>第一行代码 <code class="highlighter-rouge">Candidate qiuqiu;</code> 中的 qiuqiu 这时候可以称作是对象变量，它暂时还没有引用任何对象，严格意义上，它也不能称为 <code class="highlighter-rouge">null</code> 。</p>

<p>第二行代码 <code class="highlighter-rouge">qiuqiu = new Candidate("秋秋");</code> 可以拆分为两个部分，= 号左侧和 = 号右侧。</p>

<p>右侧的表达式 <code class="highlighter-rouge">new Candidate("秋秋")</code> 先执行，执行完后，会在堆上创建了一个 name 为“秋秋”的对象，类型为 Candidate，表达式 <code class="highlighter-rouge">new Candidate("秋秋")</code> 的值是新创建对象的引用。</p>

<p>然后再把这个引用通过 = 操作符赋值给左侧的对象变量 <code class="highlighter-rouge">qiuqiu</code>，赋值后，<code class="highlighter-rouge">qiuqiu</code>就不再是对象变量了，应该称为对象引用。</p>

<p><img src="http://www.itwanger.com/assets/images/2019/11/java-oo-po-5.png" alt="" /></p>

<p>看完老王的解释，你会不会情不自禁地“哦，原来如此啊！”反正我当时顿悟的时候是这样的。</p>

<p>前面提到，Interviewer 类的设计存在一个严重的问题，是什么呢？</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Candidate</span> <span class="n">qiuqiu</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Candidate</span><span class="o">(</span><span class="s">"秋秋"</span><span class="o">);</span>
<span class="nc">Interviewer</span> <span class="n">interviewer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Interviewer</span><span class="o">(</span><span class="n">qiuqiu</span><span class="o">);</span>

<span class="n">interviewer</span><span class="o">.</span><span class="na">getCandidate</span><span class="o">().</span><span class="na">setName</span><span class="o">(</span><span class="s">"夏夏"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">qiuqiu</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
</code></pre></div></div>

<p>这段代码执行完后，你会发现秋秋变成了夏夏，应聘者的私有成员变量 name  竟然被改变了！问题的原因也很简单，qiuqiu 和 <code class="highlighter-rouge">interviewer.getCandidate()</code> 引用了同一个对象。</p>

<p><img src="http://www.itwanger.com/assets/images/2019/11/java-oo-po-6.png" alt="" /></p>

<p>那怎么解决呢？当 <code class="highlighter-rouge">getter</code> 需要返回一个可变对象的引用时，应该先进行克隆（clone）。以下展示了一个非常简单的克隆方案。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Interviewer</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="nc">Candidate</span> <span class="n">candidate</span><span class="o">;</span>
	
	<span class="kd">public</span> <span class="nf">Interviewer</span> <span class="o">(</span><span class="nc">Candidate</span> <span class="n">candidate</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">candidate</span> <span class="o">=</span> <span class="n">candidate</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="nc">Candidate</span> <span class="nf">getCandidate</span><span class="o">()</span> <span class="o">{</span>
		<span class="nc">Candidate</span> <span class="n">candidate</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Candidate</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">candidate</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
		<span class="k">return</span> <span class="n">candidate</span><span class="o">;</span>
	<span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<h3 id="05最后">05、最后</h3>

<p>这篇文章花了 5 个多小时才写完，此刻我的感觉只有一个字——饿，我要出去吃饭了。吃饭之前，我决定先买个烤红薯吃，重温一下那种久违的香。</p>

<p>上一篇：<a href="http://www.itwanger.com/java/2019/11/14/java-double-float.html">Java面试官：兄弟，你确定double精度比float低吗？</a></p>

<p>下一篇：<a href="http://www.itwanger.com/java/2019/11/14/java-extends.html">再谈 Java 的继承和超类 Object</a></p>

<p>谢谢大家的阅读，原创不易，喜欢就随手点个赞👍，这将是我最强的写作动力。如果觉得文章对你有点帮助，还挺有趣，就关注一下我的公众号「<strong>沉默王二</strong>」。</p>
:ET