I"3<p>没事的时候，我并不喜欢逛 P 站，而喜欢逛 programcreek 这些技术型网站，于是那天晚上，在夜深人静的时候，我就发现了一个专注基础但不容忽视的主题。比如说：<strong>Java 中的 null 到底是什么鬼</strong>？像这类灵魂拷问的主题，非常值得深入地研究一下。</p>

<!--more-->

<p><img src="http://www.itwanger.com/assets/images/2020/01/java-null-01.png" alt="" /></p>

<p>null 在 Java 中是一个特殊的存在，因为它和<a href="https://mp.weixin.qq.com/s/PBqR_uj6dd4xKEX8SUWIYQ">大名鼎鼎的 <code class="highlighter-rouge">NullPointerException</code></a>（NPE）如影随形。NPE 的发明人 Tony Hoare 曾在 2009 年承认：“Null References 是一个荒唐的设计，就好像我赌输掉了十亿美元”。</p>

<p>那为什么 Java 会一直保留着 null，而没有把它消灭掉呢？我想是因为 null 的存在的确为 Java 带来了更多好处（我在下文中指出了一些，看大家能不能发现哦）。</p>

<p><img src="http://www.itwanger.com/assets/images/2020/01/java-null-02.png" alt="" /></p>

<p>就让我们从下面这个语句开始。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</code></pre></div></div>

<p>首先，我们来回顾一下：什么是变量，什么是值。举个恰当的例子，变量就好像一个窑洞，里面可以住人，也可以不住人，人就相当于值。在 Java 中，如果一个变量要存储某个值，就需要先声明是什么类型。</p>

<p>s 为一个 String 类型的变量，这一点是毫无疑问的，对吧？那肯定啊，二哥，你别废话了，怎么可能有人怀疑这一点。</p>

<p>Java 有两种类型，一种是基本类型，一种是引用类型。声明为基本类型的变量存储的是值，声明为引用类型的变量存储的是对象的引用，这一点想必大家也不怀疑吧。</p>

<p>就之前那行语句来说，String 是一个引用类型，值为 null，也就是说 s 这个变量什么也没存储，就好像一个窑洞里面什么人也没住，一样。</p>

<p>假如 <code class="highlighter-rouge">String s = "沉默王二"</code>，就可以使用下面这幅图来表示。</p>

<p><img src="http://www.itwanger.com/assets/images/2020/01/java-null-03.png" alt="" /></p>

<p>而 <code class="highlighter-rouge">String s = null</code> 的表现形式则是不同的，它没有可引用的对象。</p>

<p><img src="http://www.itwanger.com/assets/images/2020/01/java-null-04.png" alt="" /></p>

<p>那<strong>内存中的 null 到底是什么玩意呢</strong>？Java 中的 null 到底是什么样的一个值？</p>

<p>不管怎么样，null 不是一个有效的对象，所以内存中并没有为它分配空间，没它的位置。null 仅仅是一种表现符号，表明引用此时没有指向任何一个对象。Java虚拟机的规范中也没有规定 null 的具体值。</p>

<p>这不仅让我联想到了佛经中的一句经典台词，想必大家也猜到了，大声的念出来吧！“<strong>色即是空，空即是色</strong>。”我们汉语中的这个“空”字恰到好处地匹配了这个 <code class="highlighter-rouge">null</code>，换句话说就是“null 即是空，空即是 null。”经典啊，经典。</p>

<p>一个类的<strong>成员变量如果是引用类型的话，它的默认值就为 null</strong>，这和基本类型有所不同。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Null</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Null</span> <span class="n">n</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Null</span><span class="o">();</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">age</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>上面这段代码的输出结果是：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>null
0
</code></pre></div></div>

<p>但如果是一个引用类型的局部变量的话，编译器会提醒我们对其初始化。</p>

<p><img src="http://www.itwanger.com/assets/images/2020/01/java-null-05.png" alt="" /></p>

<p>如果一个变量当前没有确定要初始化的值，那么 null 就是最佳选择，即所谓的延迟初始化，直到实际使用的时候再赋值为“它实际”的值（<strong>null 的第 1 个好处</strong>）。更神奇的是，<strong>null 竟然可以被强制转化</strong>。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="kc">null</span><span class="o">;</span>
<span class="nc">Integer</span> <span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Integer</span><span class="o">)</span> <span class="kc">null</span><span class="o">;</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
</code></pre></div></div>

<p>程序不仅可以编译通过，运行时也没有抛出可怕的 NPE。但是呢，Java 还是有原则的，当把 null 赋值给基本类型变量的时候就会编译不通过。</p>

<p><img src="http://www.itwanger.com/assets/images/2020/01/java-null-06.png" alt="" /></p>

<p>编译器是不是很智能，很人性化，毕竟基本类型和引用类型是不同的，null 只能作为引用类型的初始化值，却不能作为基本类型的初始化值，因为基本类型有自己的初始化值，比如说 int 的为 0。不过，不要太轻信人工智能化，我保证能把编译器绕晕。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span> <span class="n">j</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">k</span><span class="o">);</span>
</code></pre></div></div>

<p>先给基本类型的包装类型变量赋值为 null，再把该变量赋值给基本类型变量，编译器就无能为力了。不过，NPE 会在运行时被揪出来鞭尸了。</p>

<p>关于 null，还有另外一个有趣的事实：<strong>如果使用了带有 null 值的引用类型变量，instanceof 将会返回 false</strong>。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span> <span class="k">instanceof</span> <span class="nc">String</span><span class="o">);</span> <span class="c1">// false</span>
</code></pre></div></div>

<p>也就是说，如果一个引用类型变量的值不为 null，并且在使用 instanceof 操作符判断类型的时候没有抛出 <code class="highlighter-rouge">ClassCastException</code>，那么结果就为 true。否则，即便是为一个变量明确地声明了类型，比如说 <code class="highlighter-rouge">String s1 = null</code>，instanceof 仍然无法知道 s1 是 String 类型。</p>

<p>好了，我们再来看一看 null 的其他用途，比如说表示对象不存在、终止条件。</p>

<p>下图是 <code class="highlighter-rouge">System.console()</code> 方法的 Javadoc，该方法会返回与当前 Java 虚拟机相关联的唯一对象（如果有的话）；如果没有的话，返回 null。</p>

<p><img src="http://www.itwanger.com/assets/images/2020/01/java-null-07.png" alt="" /></p>

<p>想想看，如果 Java 没有保留 null 的话，要返回什么呢？至少得再定义一个和 null 差不多意义的关键字。</p>

<p>再来看看另外一个例子，来自 <code class="highlighter-rouge">java.io.BufferedReader</code> 类的 <code class="highlighter-rouge">readLine()</code> 方法</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">String</span> <span class="nf">readLine</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span>

<span class="nl">Returns:</span> <span class="no">A</span> <span class="nc">String</span> <span class="n">containing</span> <span class="n">the</span> <span class="n">contents</span> <span class="n">of</span> <span class="n">the</span> <span class="n">line</span><span class="o">,</span> <span class="n">not</span> <span class="n">including</span> <span class="n">any</span> <span class="n">line</span><span class="o">-</span><span class="n">termination</span> <span class="n">characters</span><span class="o">,</span> <span class="n">or</span> <span class="kc">null</span> <span class="k">if</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span> <span class="n">the</span> <span class="n">stream</span> <span class="n">has</span> <span class="n">been</span> <span class="n">reached</span><span class="o">.</span>
</code></pre></div></div>

<p>该方法会一行一行地返回读取的字符串，直到流的结尾。怎么判断到了流的结尾呢，返回 null。这样的话，我们就可以把判 null 作为读取字符串的条件。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">line</span><span class="o">;</span>
<span class="k">while</span> <span class="o">((</span><span class="n">line</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
   <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">line</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>当然了，也可以返回其他的关键字，比如说 -1，来表示 <code class="highlighter-rouge">readLine()</code> 到了流的末尾，但这样的做法和返回 null 没有多大的分别。</p>

<p>最后，奉上一句罗素同学的名言：“<strong>存在即合理</strong>。”null 既然已经存在了，自然有它存在的道理，不管它的功过是非。</p>

<hr />

<p>好了，各位读者朋友们，以上就是本文的全部内容了。能看到这里的都是最优秀的程序员，升职加薪就是你了👍。<strong>原创不易，如果觉得有点用的话，请不要吝啬你手中点赞的权力</strong>。</p>

<p>PS：当然还有更多好看的 Java 原创文章，比较多，这里不便一一列举，感兴趣的可以到公众号【沉默王二】回复【null】获取。</p>
:ET