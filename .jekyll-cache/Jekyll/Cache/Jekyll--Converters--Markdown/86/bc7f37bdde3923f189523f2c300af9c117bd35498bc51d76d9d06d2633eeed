I"e`<p>《Java编程思想》第四版足足用了75页来讲<strong>泛型</strong>——厚厚的一沓内容，很容易让人头大——但其实根本不用这么多，只需要一句话：我是一个泛型队列，狗可以站进来，猫也可以站进来，但最好不要既站猫，又站狗！</p>

<!--more-->

<h3 id="01泛型是什么">01、泛型是什么</h3>

<p>泛型，有人拆解这个词为“参数化类型”。这种拆解其实也不好理解，还是按照沉默王二的意思来理解一下吧。</p>

<p>现在有一只玻璃杯，你可以让它盛一杯白开水，也可以盛一杯二锅头——泛型的概念就在于此，<strong>制造这只杯子的时候</strong>没必要在说明书上定义死，指明它只能盛白开水而不能盛二锅头！</p>

<p>可以在说明书上指明它用来盛装液体，但最好也不要这样，弄不好用户想用它来盛几块冰糖呢！</p>

<p>这么一说，你是不是感觉不那么抽象了？泛型其实就是在定义类、接口、方法的时候不局限地指定某一种特定类型，而让类、接口、方法的调用者来决定具体使用哪一种类型的参数。</p>

<p>就好比，玻璃杯的制造者说，我不知道使用者用这只玻璃杯来干嘛，所以我只负责造这么一只杯子；玻璃杯的使用者说，这就对了，我来决定这只玻璃杯是盛白开水还是二锅头，或者冰糖。</p>

<h3 id="02什么时候用泛型">02、什么时候用泛型</h3>

<p>我们来看一段简短的代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Cmower</span> <span class="o">{</span>

	<span class="kd">class</span> <span class="nc">Dog</span> <span class="o">{</span>
	<span class="o">}</span>

	<span class="kd">class</span> <span class="nc">Cat</span> <span class="o">{</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">Cmower</span> <span class="n">cmower</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Cmower</span><span class="o">();</span>
		<span class="nc">Map</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">();</span>
		<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"dog"</span><span class="o">,</span> <span class="n">cmower</span><span class="o">.</span><span class="na">new</span> <span class="nf">Dog</span><span class="o">());</span>
		<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"cat"</span><span class="o">,</span> <span class="n">cmower</span><span class="o">.</span><span class="na">new</span> <span class="nf">Cat</span><span class="o">());</span>

		<span class="nc">Cat</span> <span class="n">cat</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Cat</span><span class="o">)</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"dog"</span><span class="o">);</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">cat</span><span class="o">);</span>
	<span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>这段代码的意思是：我们在map中放了一只狗（Dog），又放了一只猫（Cat），当我们想从map中取出猫的时候，却一不留神把狗取了出来。</p>

<p>这段代码编译是没有问题的，但运行的时候就会报<code class="highlighter-rouge">ClassCastException</code>（狗毕竟不是猫啊）：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Exception in thread "main" java.lang.ClassCastException: com.cmower.java_demo.sixteen.Cmower$Dog cannot be cast to com.cmower.java_demo.sixteen.Cmower$Cat
	at com.cmower.java_demo.sixteen.Cmower.main(Cmower.java:20)
</code></pre></div></div>

<p>为什么会这样呢？</p>

<p>1）写代码的程序员粗心大意。要从map中把猫取出来，你不能取狗啊！</p>

<p>2）创建map的时候，没有明确指定map中要放的类型。如果指定是要放猫，那肯定取的时候就是猫，不会取出来狗；如果指定是要放狗，也一个道理。</p>

<p>第一种情况不太好解决，总不能把程序员打一顿（我可不想做一个天天背锅的程序员，很重的好不好）；第二种情况就比较容易解决，因为Map支持泛型（泛型接口）。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div>

<p>注：在Java中，经常用T、E、K、V等形式的参数来表示泛型参数。</p>

<p>T：代表一般的任何类。
E：代表 Element 的意思，或者 Exception 异常的意思。
K：代表 Key 的意思。
V：代表 Value 的意思，通常与 K 一起配合使用。</p>

<p>既然Map支持泛型，那作为Map的实现者HashMap（泛型类）也支持泛型了。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">AbstractMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span>
    <span class="kd">implements</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;,</span> <span class="nc">Cloneable</span><span class="o">,</span> <span class="nc">Serializable</span> <span class="o">{</span>
    
<span class="o">}</span>
</code></pre></div></div>

<p>其中的put方法（泛型方法）是这样定义的：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="no">V</span> <span class="nf">put</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="nf">putVal</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>好了，现在使用泛型的形式来定义一个只能放Cat的Map吧！</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Cmower</span> <span class="o">{</span>

	<span class="kd">class</span> <span class="nc">Dog</span> <span class="o">{</span>
	<span class="o">}</span>

	<span class="kd">class</span> <span class="nc">Cat</span> <span class="o">{</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">Cmower</span> <span class="n">cmower</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Cmower</span><span class="o">();</span>
		<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Cat</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
<span class="c1">//		map.put("dog", cmower.new Dog()); // 不再允许添加</span>
		<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"cat"</span><span class="o">,</span> <span class="n">cmower</span><span class="o">.</span><span class="na">new</span> <span class="nf">Cat</span><span class="o">());</span>

		<span class="nc">Cat</span> <span class="n">cat</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"cat"</span><span class="o">);</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">cat</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>当使用泛型定义map（键为String类型，值为Cat类型）后：</p>

<p>1）编译器就不再允许你向map中添加狗的对象了。</p>

<p>2）当你从map中取出猫的时候，也不再需要强制转型了。</p>

<h3 id="03类型擦除">03、类型擦除</h3>

<p>有人说，Java的泛型做的只是表面功夫——泛型信息存在于编译阶段（狗队在编译时不允许站猫），运行阶段就消失了（运行时的队列里没有猫的信息，连狗的信息也没有）——这种现象被称为“类型擦除”。</p>

<p>来，看代码解释一下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Cmower</span> <span class="o">{</span>

	<span class="kd">class</span> <span class="nc">Dog</span> <span class="o">{</span>
	<span class="o">}</span>

	<span class="kd">class</span> <span class="nc">Cat</span> <span class="o">{</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">Cmower</span> <span class="n">cmower</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Cmower</span><span class="o">();</span>
		<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Cat</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
		<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Dog</span><span class="o">&gt;</span> <span class="n">map1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
		
		<span class="c1">// The method put(String, Cmower.Cat) in the type Map&lt;String,Cmower.Cat&gt; is not applicable for the arguments (String, Cmower.Dog)</span>
		<span class="c1">//map.put("dog",cmower.new Dog());</span>
		
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span>
		<span class="c1">// 输出：class java.util.HashMap</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map1</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span>
		<span class="c1">// 输出：class java.util.HashMap</span>
	<span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>map的键位上是Cat，所以不允许put一只Dog；否则编译器会提醒<code class="highlighter-rouge">The method put(String, Cmower.Cat) in the type Map&lt;String,Cmower.Cat&gt; is not applicable for the arguments (String, Cmower.Dog)</code>。编译器做得不错，值得点赞。</p>

<p>但是问题就来了，map的Class类型为HashMap，map1的Class类型也为HashMap——也就是说，Java代码在运行的时候并不知道map的键位上放的是Cat，map1的键位上放的是Dog。</p>

<p>那么，试着想一些可怕的事情：既然运行时泛型的信息被擦除了，而反射机制是在运行时确定类型信息的，那么利用反射机制，是不是就能够在键位为Cat的Map上放一只Dog呢？</p>

<p>我们不妨来试一试：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Cmower</span> <span class="o">{</span>

	<span class="kd">class</span> <span class="nc">Dog</span> <span class="o">{</span>
	<span class="o">}</span>

	<span class="kd">class</span> <span class="nc">Cat</span> <span class="o">{</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">Cmower</span> <span class="n">cmower</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Cmower</span><span class="o">();</span>
		<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Cat</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
		
		<span class="k">try</span> <span class="o">{</span>
			<span class="nc">Method</span> <span class="n">method</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getDeclaredMethod</span><span class="o">(</span><span class="s">"put"</span><span class="o">,</span><span class="nc">Object</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">Object</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
			
			<span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">map</span><span class="o">,</span><span class="s">"dog"</span><span class="o">,</span> <span class="n">cmower</span><span class="o">.</span><span class="na">new</span> <span class="nf">Dog</span><span class="o">());</span>
			
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>
			<span class="c1">// {dog=com.cmower.java_demo.sixteen.Cmower$Dog@55f96302}</span>
		<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">NoSuchMethodException</span> <span class="o">|</span> <span class="nc">SecurityException</span> <span class="o">|</span> <span class="nc">IllegalAccessException</span> <span class="o">|</span> <span class="nc">IllegalArgumentException</span> <span class="o">|</span> <span class="nc">InvocationTargetException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
		<span class="o">}</span>
	<span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>看到没？我们竟然在键位为Cat的Map上放了一只Dog！</p>

<p>注：Java的设计者在JDK 1.5时才引入了泛型，但为了照顾以前设计上的缺陷，同时兼容非泛型的代码，不得不做出了一个折中的策略：编译时对泛型要求严格，运行时却把泛型擦除了——要兼容以前的版本，还要升级扩展新的功能，真的很不容易！</p>

<h3 id="04泛型通配符">04、泛型通配符</h3>

<p>有些时候，你会见到这样一些代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Number</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="nc">Number</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">?</code>和关键字<code class="highlighter-rouge">extends</code>或者<code class="highlighter-rouge">super</code>在一起其实就是泛型的高级应用：通配符。</p>

<p>我们来自定义一个泛型类——PetHouse（宠物小屋），它有一些基本的动作（可以住进来一只宠物，也可以放出去）：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PetHouse</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">;</span>

	<span class="kd">public</span> <span class="nf">PetHouse</span><span class="o">()</span> <span class="o">{</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="no">T</span> <span class="n">item</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="no">T</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>如果我们想要住进去一只宠物，可以这样定义小屋（其泛型为Pet）：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">PetHouse</span><span class="o">&lt;</span><span class="nc">Pet</span><span class="o">&gt;</span> <span class="n">petHouse</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PetHouse</span><span class="o">&lt;&gt;();</span>
</code></pre></div></div>

<p>然后，我们让小猫和小狗住进去：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">petHouse</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Cat</span><span class="o">());</span>
<span class="n">petHouse</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Dog</span><span class="o">());</span>
</code></pre></div></div>

<p>如果我们只想要住进去一只小猫，打算这样定义小屋：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">PetHouse</span><span class="o">&lt;</span><span class="nc">Pet</span><span class="o">&gt;</span> <span class="n">petHouse</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PetHouse</span><span class="o">&lt;</span><span class="nc">Cat</span><span class="o">&gt;();</span>
</code></pre></div></div>

<p>但事实上，编译器不允许我们这样定义：因为泛型不直接支持向上转型。该怎么办呢？</p>

<p>可以这样定义小屋：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">PetHouse</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Pet</span><span class="o">&gt;</span> <span class="n">petHouse</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PetHouse</span><span class="o">&lt;</span><span class="nc">Cat</span><span class="o">&gt;();</span>
</code></pre></div></div>

<p>也就是说，宠物小屋可以住进去小猫，但它必须是宠物（Pet或者Pet的子类）而不是一只野猫。</p>

<p>但很遗憾，这个宠物小屋实际上住不了小猫，看下图。</p>

<p><img src="http://www.itwanger.com/assets/images/2019/11/java-fanxing-1.png" alt="" /></p>

<p>这是因为Java虽然支持泛型的向上转型（使用 <code class="highlighter-rouge">extends</code> 通配符），但我们却无法向其中添加任何东西——编译器并不知道宠物小屋里要住的是小猫还是小狗，或者其他宠物，因此干脆什么都不让住。</p>

<p>看到这，你一定非常疑惑，既然<code class="highlighter-rouge">PetHouse&lt;? extends Pet&gt;</code>定义的宠物小屋什么也不让住，那为什么还要这样定义呢？思考一下。</p>

<h3 id="05读者将军的总结">05、读者将军的总结</h3>

<p>泛型限定符有一描述：上界不存下界不取。</p>

<p>上界不存的原因：例如 List，编译器只知道容器内是 Father 及其子类，具体是什么类型并不知道，编译器在看到 extends 后面的 Father 类，只是标上一个 <code class="highlighter-rouge">CAP#1</code> 作为占位符，无论往里面插什么，编译器都不知道能不能和 <code class="highlighter-rouge">CAP#1</code> 匹配，所以就不允许插入。</p>

<p>extends的作用：可以在初始化的时候存入一个值，并且能保证数据的稳定性，只能取不能存。读取出来的数据可以存在父类或者基类里。</p>

<p>下界不取的原因：下界限定了元素的最小粒度，实际上是放松了容器元素的类型控制。例如 List， 元素是 Father 的基类，可以存入 Father 及其子类。但编译器并不知道哪个是 Father 的超类，如 Human。读取的时候，自然不知道是什么类型，只能返回 Object，这样元素信息就全部丢失了。</p>

<p>super的作用：用于参数类型限定。</p>

<p>PECS 原则：</p>

<p>1.频繁往外读取内容的，适合用extends
2.经常往里插入的，适合用super</p>

<hr />

<p>上一篇：<a href="http://www.itwanger.com/java/2019/11/08/java-hashmap.html">HashMap，难的不在Map，而在Hash</a></p>

<p>下一篇：<a href="http://www.itwanger.com/java/2019/11/08/java-exception.html">Java异常处理：给程序罩一层保险</a></p>

<p>微信搜索「<strong>沉默王二</strong>」公众号，关注后回复「<strong>免费视频</strong>」获取 500G 高质量教学视频（<a href="https://mp.weixin.qq.com/s/GjkEyPW0vgIvuDLYQkBM0A">已分门别类</a>）。</p>
:ET