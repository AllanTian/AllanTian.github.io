I"2<p>Java内部类真的很难理解，但有必要搞懂，因为内部类让外部类更丰富多彩了，就好像一个人的心中还可以住着另外一个人。</p>

<!--more-->

<h3 id="01-前言">01 前言</h3>

<p>昨天晚上，我把车停好以后就回家了。回家后才发现手机落在车里面了，但外面太冷，冷到骨头都能感受到寒意——实在是不想返回一趟去取了（小区的安保还不错，不用担心被砸车玻璃），于是打定主意过几个小时的“世外桃源”生活——别人找不到我，我也找不到别人，这种与世隔绝的状态非常适合读书写作。</p>

<p>把厚厚的《Java编程思想》摆在桌子上，正襟危坐，认认真真地读起了第十章——内部类。尽管我已经非常耐心和用心了，但内部类的这一章非常的枯燥，并且难以理解，我整个人几乎处于崩溃的边缘。</p>

<p>很早之前，有想要转行学习Java的朋友咨询我，有哪方面的书可以推荐，我郑重其事地介绍了《Java编程思想》，并且一再叮嘱他这是一本Java入门级的经典书，必须耐着性子读完它。现在想想，自己当时的推荐真是轻率！</p>

<p>我这样说，并不是为了否认《Java编程思想》这本书的价值，因为站在书本的角度，它可能会感慨说：这王二的学习能力有问题啊，读我竟然这么困难！</p>

<p>不是有那样一句话嘛：“<strong>如果你手里有一把锤子，所有东西看上去都像钉子</strong>。”我认为“内部类”这一章很难懂，其根本的原因在于我对“内部类”没有很好的理解。想要继续扎实Java的基础知识，唯一要做的就是——想尽一切办法搞懂“内部类”，并梳理成文。</p>

<h3 id="02-内部类的定义">02 内部类的定义</h3>

<p>顾名思义，<strong>内部类就是放在另外一个类的内部定义的类</strong>。非常重要的一点是，内部类能够访问外部类的所有成员，包括<code class="highlighter-rouge">private</code>修饰的。</p>

<p>来看程序清单1-1：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Wanger</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
	<span class="kd">public</span> <span class="nf">Wanger</span><span class="o">(</span><span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="kd">class</span> <span class="nc">Thought</span> <span class="o">{</span>
		<span class="kd">public</span> <span class="kt">void</span> <span class="nf">know</span><span class="o">()</span> <span class="o">{</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"沉默王二的年龄"</span> <span class="o">+</span> <span class="n">age</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="nc">Thought</span> <span class="nf">getThought</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="nf">Thought</span><span class="o">();</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">Wanger</span> <span class="n">wanger</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Wanger</span><span class="o">(</span><span class="mi">29</span><span class="o">);</span>
		<span class="nc">Wanger</span><span class="o">.</span><span class="na">Thought</span> <span class="n">thought</span> <span class="o">=</span> <span class="n">wanger</span><span class="o">.</span><span class="na">getThought</span><span class="o">();</span>
		<span class="n">thought</span><span class="o">.</span><span class="na">know</span><span class="o">();</span> <span class="c1">// 输出：沉默王二的年龄29</span>
		
		<span class="c1">// 使用.new的形式创建内部类对象</span>
		<span class="nc">Wanger</span><span class="o">.</span><span class="na">Thought</span> <span class="n">thought1</span> <span class="o">=</span> <span class="n">wanger</span><span class="o">.</span><span class="na">new</span> <span class="nf">Thought</span><span class="o">();</span>
		<span class="n">thought1</span><span class="o">.</span><span class="na">know</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>程序清单1-1要表达什么意思呢？</p>

<p>答案是：我，沉默王二，已经29岁了，89年出生（有人说89年出生明明是30岁）。上了年纪了，总想装点嫩，理解一下。我读书不多，但特别爱思考，于是我就给自己创建了一个会思考的内部类Thought。</p>

<p>从程序清单1-1可以看得出，尽管Thought是内部类，但可以访问外部类Wanger的私有成员变量age。</p>

<p>如果想创建内部类的对象，需要先指明对象引用的类型，格式为OuterClassName.InnerClassName，就像main()方法中的<code class="highlighter-rouge">Wanger.Thought</code>那样。</p>

<p>紧接着，就要来创建内部类对象了，有两种形式。第一种形式是先在外部类中定义一个方法<code class="highlighter-rouge">Thought getThought()</code>，返回使用<code class="highlighter-rouge">new</code>关键字创建的内部类对象，然后使用外部类对象调用该方法<code class="highlighter-rouge">wanger.getThought()</code>；第二种形式是直接通过外部类对象<code class="highlighter-rouge">.new</code>创建<code class="highlighter-rouge">wanger.new Thought()</code>。</p>

<h3 id="03-匿名内部类">03 匿名内部类</h3>

<p>以我的编程经验来看，匿名内部类使用最频繁的场合就是在创建线程的时候。</p>

<p>来看程序清单2-1：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo</span> <span class="o">{</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">(</span><span class="nc">String</span> <span class="n">title</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>

			<span class="nd">@Override</span>
			<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
				<span class="c1">// title = "我不要吃鸡";</span>
				<span class="c1">// 改变时会提示错误</span>
				<span class="c1">// 在封闭范围中定义的局部变量必须是final的。</span>
				<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">title</span><span class="o">);</span>
			<span class="o">}</span>
		<span class="o">});</span>
		<span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="nc">Demo</span> <span class="n">demo</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Demo</span><span class="o">();</span>
			<span class="n">demo</span><span class="o">.</span><span class="na">test</span><span class="o">(</span><span class="s">"我要吃鸡"</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span>
	
<span class="o">}</span>
</code></pre></div></div>

<p>在程序清单2-1中，test()方法内部有一个线程对象thread，是通过new Thread()创建的。<code class="highlighter-rouge">new Thread()</code>可以接收一个实现了Runnable接口类型的对象，这个对象要怎么创建呢？可以通过匿名内部类的形式来创建——<code class="highlighter-rouge">new Runnable() {public void run(){......}}</code>——这段简短的代码等同于：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 实现Runnable接口</span>
<span class="kd">class</span> <span class="nc">MyRunnable</span> <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
		
	<span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 向上转型</span>
<span class="nc">Runnable</span> <span class="n">myRunnable</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyRunnable</span><span class="o">();</span>
</code></pre></div></div>

<p><strong>匿名内部类的好处就在于不仅节省了定义实现类的过程，还能够自动向上转型</strong>。</p>

<p>在程序清单2-1中，test()方法还有一个参数title，JDK1.8之前，编译器要求它必须是final类型的。但JDK1.8之后，如果我们在匿名内部类中需要访问局部变量，那么这个局部变量不再需要用<code class="highlighter-rouge">final</code>关键字修饰了。</p>

<p>但如果想要在匿名内部类中改变局部变量的值，编译器就会提醒你不能这样做，它会提示：“在封闭范围中定义的局部变量必须是final的。”</p>

<h3 id="04-为什么需要内部类">04 为什么需要内部类</h3>

<p>Java的内部类让我很容易的想起来JavaScript的闭包，闭包就是定义在一个函数内部的函数——这听起来和Java的内部类定义一样一样的。本质上，闭包是将函数内部与函数外部连接起来的桥梁。内部类一样，它是将内部类与外部类连接起来的桥梁。</p>

<p>来看看什么是闭包吧：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">wanger</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">age</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
	<span class="kd">function</span> <span class="nx">know</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">age</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="nx">wanger</span><span class="p">();</span>
<span class="c1">// 控制台输出30</span>
</code></pre></div></div>

<p>除此之外，内部类最引人注意的原因是：</p>

<p><strong>内部类可以独立地继承一个抽象类或者实现一个接口，无论外部类是否也这样做了，对内部类都没有影响</strong>。</p>

<hr />

<p>上一篇：<a href="http://www.itwanger.com/java/2019/11/06/java-abstract-interface.html">Java 抽象类和接口，看这一篇就够了</a></p>

<p>下一篇：<a href="http://www.itwanger.com/java/2019/11/08/java-string.html">Java String，看这篇就够了</a></p>

<p>微信搜索「<strong>沉默王二</strong>」公众号，关注后回复「<strong>免费视频</strong>」获取 500G Java 高质量教学视频（已分门别类）。</p>
:ET