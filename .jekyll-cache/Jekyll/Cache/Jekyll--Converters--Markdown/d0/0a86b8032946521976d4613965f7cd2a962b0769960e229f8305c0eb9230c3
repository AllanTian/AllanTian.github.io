I""n<p>Java 之所以能够霸占编程语言的榜首，其强大、丰富的类库功不可没，几乎所有的编程问题都能在其中找到解决方案。但在早期的版本当中，输入输出（I/O）流并不那么令开发者感到愉快：</p>

<p>1）JDK 1.4 之前的 I/O 没有缓冲区的概念、不支持正则表达式、支持的字符集编码有限等等；
2）JDK 1.4 的时候引入了非阻塞 I/O，也就是 NIO 1.0，但遍历目录很困难，不支持文件系统的非阻塞操作等等。</p>

<p>为了突破这些限制，JDK 1.7 的时候引入了新的 NIO，也就是本篇文章的主角——NIO 2.0。</p>

<!--more-->

<h3 id="01基石path">01、基石：Path</h3>

<p>Path 既可以表示一个目录，也可以表示一个文件，就像 File 那样——当然了，Path 就是用来取代 File 的。</p>

<p>1）可以通过 <code class="highlighter-rouge">Paths.get()</code> 创建一个 Path 对象，此时 Path 并没有真正在物理磁盘上创建；参数既可以是一个文件名，也可以是一个目录名；绝对路径或者相对路径均可。</p>

<p>2）可以通过 <code class="highlighter-rouge">Files.notExists()</code> 确认 Path（目录或者文件） 是否已经存在。</p>

<p>3）可以通过 <code class="highlighter-rouge">Files.createDirectory()</code> 创建目录，此时目录已经在物理磁盘上创建成功，可通过资源管理器查看到。</p>

<p>4）可以通过 <code class="highlighter-rouge">Files.createFile()</code> 创建文件，此时文件已经在物理磁盘上创建成功，可通过资源管理器查看到。</p>

<p>5）可以通过 <code class="highlighter-rouge">toAbsolutePath()</code> 查看 Path 的绝对路径。</p>

<p>6）可以通过 <code class="highlighter-rouge">resolve()</code> 将 Path 连接起来，参数可以是一个新的 Path 对象，也可以是对应的字符串。</p>

<p>具体的代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Wanger</span> <span class="o">{</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="c1">// 相对路径</span>
		<span class="nc">Path</span> <span class="n">dir</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"chenmo"</span><span class="o">);</span>

		<span class="c1">// 输出 dir 的绝对路径</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">dir</span><span class="o">.</span><span class="na">toAbsolutePath</span><span class="o">());</span> <span class="c1">// 输出：D:\program\java.git\java_demo\chenmo</span>

		<span class="k">if</span> <span class="o">(</span><span class="nc">Files</span><span class="o">.</span><span class="na">notExists</span><span class="o">(</span><span class="n">dir</span><span class="o">))</span> <span class="o">{</span>
			<span class="k">try</span> <span class="o">{</span>
				<span class="c1">// 如果目录不存在，则创建目录</span>
				<span class="nc">Files</span><span class="o">.</span><span class="na">createDirectory</span><span class="o">(</span><span class="n">dir</span><span class="o">);</span>
			<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e1</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">e1</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
			<span class="o">}</span>
		<span class="o">}</span>
		
		<span class="c1">// 这时候 chenmo.txt 文件并未创建</span>
		<span class="c1">// 通过 resolve 方法把 dir 和 chenmo.txt 链接起来</span>
		<span class="nc">Path</span> <span class="n">file</span> <span class="o">=</span> <span class="n">dir</span><span class="o">.</span><span class="na">resolve</span><span class="o">(</span><span class="s">"chenmo.txt"</span><span class="o">);</span>

		<span class="c1">// 输出 file 的绝对路径</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">toAbsolutePath</span><span class="o">());</span> <span class="c1">// 输出：D:\program\java.git\java_demo\chenmo\chenmo.txt</span>

		<span class="k">if</span> <span class="o">(</span><span class="nc">Files</span><span class="o">.</span><span class="na">notExists</span><span class="o">(</span><span class="n">file</span><span class="o">))</span> <span class="o">{</span>
			<span class="k">try</span> <span class="o">{</span>
				<span class="c1">// 如果文件不存在，则创建文件</span>
				<span class="nc">Files</span><span class="o">.</span><span class="na">createFile</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
			<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
			<span class="o">}</span>
		<span class="o">}</span>

	<span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>如果要将 File 转换为 Path，可以通过 File 类的 <code class="highlighter-rouge">toPath()</code> 方法完成。代码示例如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">File</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"沉默王二.txt"</span><span class="o">);</span>
<span class="nc">Path</span> <span class="n">path</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="na">toPath</span><span class="o">();</span>
</code></pre></div></div>

<p>如果要将 Path 转换为 File，可以通过 Path 类的 <code class="highlighter-rouge">toFile()</code> 方法完成。代码示例如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Path</span> <span class="n">path</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"沉默王二.txt"</span><span class="o">);</span>
<span class="nc">File</span> <span class="n">file</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="na">toFile</span><span class="o">();</span>
</code></pre></div></div>

<h3 id="02处理目录">02、处理目录</h3>

<p>NIO 2.0 新增的 <code class="highlighter-rouge">java.nio.file.DirectoryStream&lt;T&gt;</code> 接口可以非常方便地查找目录中的（符合某种规则的）文件，比如说我们要查找 chenmo 目录下的 txt 后缀的文件，代码示例如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 相对路径</span>
<span class="nc">Path</span> <span class="n">dir</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"chenmo"</span><span class="o">);</span>

<span class="k">try</span> <span class="o">(</span><span class="nc">DirectoryStream</span><span class="o">&lt;</span><span class="nc">Path</span><span class="o">&gt;</span> <span class="n">stream</span> <span class="o">=</span> <span class="nc">Files</span><span class="o">.</span><span class="na">newDirectoryStream</span><span class="o">(</span><span class="n">dir</span><span class="o">,</span> <span class="s">"*.txt"</span><span class="o">))</span> <span class="o">{</span>
	<span class="k">for</span> <span class="o">(</span><span class="nc">Path</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">stream</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">getFileName</span><span class="o">());</span>
	<span class="o">}</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
	<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>1）<code class="highlighter-rouge">Files.newDirectoryStream(Path dir, String glob)</code> 会返回一个过滤后的 DirectoryStream（ 目录流，），第一个参数为目录，第二个参数为 glob 表达式，比如 <code class="highlighter-rouge">*.txt</code> 表示所有 txt 后缀的文件。</p>

<p>2）由于 DirectoryStream 继承了 Closeable 接口，所以它可以配合 try-with-resources 语法写出更安全的代码，目录流会自动调用 close 方法关闭流，释放与流相关的资源，不需要再通过 finally 进行主动关闭。</p>

<p>3）DirectoryStream 被称为目录流，允许方便地使用 for-each 结构来遍历目录。</p>

<h3 id="03处理目录树">03、处理目录树</h3>

<p>目录树意味着一个目录里既有文件也有子目录，也可能都没有，也可能有其一。NIO 2.0 可以很方便地遍历一颗目录树，并操作符合条件的文件；这其中关键的一个方法就是 Files 类的 walkFileTree，其定义如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="nc">Path</span> <span class="nf">walkFileTree</span><span class="o">(</span><span class="nc">Path</span> <span class="n">start</span><span class="o">,</span> <span class="nc">FileVisitor</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="nc">Path</span><span class="o">&gt;</span> <span class="n">visitor</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="nc">IOException</span>
    <span class="o">{</span>
        <span class="k">return</span> <span class="nf">walkFileTree</span><span class="o">(</span><span class="n">start</span><span class="o">,</span>
                            <span class="nc">EnumSet</span><span class="o">.</span><span class="na">noneOf</span><span class="o">(</span><span class="nc">FileVisitOption</span><span class="o">.</span><span class="na">class</span><span class="o">),</span>
                            <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">,</span>
                            <span class="n">visitor</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>第二个参数 FileVisitor 被称为文件访问器接口，它实现起来非常复杂，要实现 5 个方法呢，但幸好 JDK 的设计者提供了一个默认的实现类 SimpleFileVisitor，如果我们只想从目录树中找到 txt 后缀的文件，可以这样做：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 相对路径</span>
<span class="nc">Path</span> <span class="n">dir</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"chenmo"</span><span class="o">);</span>

<span class="k">try</span> <span class="o">{</span>
	<span class="nc">Files</span><span class="o">.</span><span class="na">walkFileTree</span><span class="o">(</span><span class="n">dir</span><span class="o">,</span> <span class="k">new</span> <span class="nc">SimpleFileVisitor</span><span class="o">&lt;</span><span class="nc">Path</span><span class="o">&gt;()</span> <span class="o">{</span>
		<span class="nd">@Override</span>
		<span class="kd">public</span> <span class="nc">FileVisitResult</span> <span class="nf">visitFile</span><span class="o">(</span><span class="nc">Path</span> <span class="n">file</span><span class="o">,</span> <span class="nc">BasicFileAttributes</span> <span class="n">attrs</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">toString</span><span class="o">().</span><span class="na">endsWith</span><span class="o">(</span><span class="s">".txt"</span><span class="o">))</span> <span class="o">{</span>
				<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">getFileName</span><span class="o">());</span>
			<span class="o">}</span>
			<span class="k">return</span> <span class="nc">FileVisitResult</span><span class="o">.</span><span class="na">CONTINUE</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">});</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
	<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>通过创建匿名内部类来重写 SimpleFileVisitor 的 visitFile 方法，如果后缀名为 txt 就打印出来。</p>

<h3 id="04文件的删除复制移动">04、文件的删除、复制、移动</h3>

<p>创建一个文件非常的简单，之前我们已经体验过了，那么删除一个文件也同样的简单，代码示例如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Files</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
<span class="nc">Files</span><span class="o">.</span><span class="na">deleteIfExists</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
</code></pre></div></div>

<p>使用 <code class="highlighter-rouge">Files.delete()</code> 删除文件之前最好使用 <code class="highlighter-rouge">Files.exists()</code> 判断文件是否存在，否则会抛出 NoSuchFileException；<code class="highlighter-rouge">Files.deleteIfExists()</code> 则不用。</p>

<p>复制文件也不复杂，代码示例如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Path</span> <span class="n">source</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"沉默王二.txt"</span><span class="o">);</span>
<span class="nc">Path</span> <span class="n">target</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"沉默王二1.txt"</span><span class="o">);</span>
<span class="nc">Files</span><span class="o">.</span><span class="na">copy</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="n">target</span><span class="o">);</span>
</code></pre></div></div>

<p>移动文件和复制文件非常相似，代码示例如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Path</span> <span class="n">source</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"沉默王二.txt"</span><span class="o">);</span>
<span class="nc">Path</span> <span class="n">target</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"沉默王二1.txt"</span><span class="o">);</span>
<span class="nc">Files</span><span class="o">.</span><span class="na">move</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="n">target</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="05快速地读写文件">05、快速地读写文件</h3>

<p>NIO 2.0 提供了带有缓冲区的读写辅助方法，使用起来也非常的简单。可以通过 <code class="highlighter-rouge">Files.newBufferedWriter()</code> 获取一个文件缓冲输入流，并通过 <code class="highlighter-rouge">write()</code> 方法写入数据；然后通过 <code class="highlighter-rouge">Files.newBufferedReader()</code> 获取一个文件缓冲输出流，通过 <code class="highlighter-rouge">readLine()</code> 方法读出数据。代码示例如下。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Path</span> <span class="n">file</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"沉默王二.txt"</span><span class="o">);</span>

<span class="k">try</span> <span class="o">(</span><span class="nc">BufferedWriter</span> <span class="n">writer</span> <span class="o">=</span> <span class="nc">Files</span><span class="o">.</span><span class="na">newBufferedWriter</span><span class="o">(</span><span class="n">file</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">))</span> <span class="o">{</span>
	<span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"一个有趣的程序员"</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
	<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span>

<span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">reader</span> <span class="o">=</span> <span class="nc">Files</span><span class="o">.</span><span class="na">newBufferedReader</span><span class="o">(</span><span class="n">file</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">))</span> <span class="o">{</span>

	<span class="nc">String</span> <span class="n">line</span><span class="o">;</span>
	<span class="k">while</span> <span class="o">((</span><span class="n">line</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">line</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
	<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="06重要异步-io-操作">06、重要：异步 I/O 操作</h3>

<p>实话实说吧，上面提到的那些都算是 NIO 2.0 的甜点，而异步 I/O 操作（也称 AIO）才算是真正重要的内容。异步 I/O 操作可以充分利用多核 CPU 的特点，不需要再像以前那样启动一个线程来对 I/O 进行处理，免得阻塞了主线程的其他操作。</p>

<p>异步 I/O 操作的核心概念是发起非阻塞方式的 I/O 操作，当 I/O 操作完成时通知。可以分为两种形式：Future 和 Callback。如果我们希望主线程发起 I/O 操作并轮循等待结果时，一般使用 Future 的形式；而 Callback 的基本思想是主线程派出一个侦查员（CompletionHandler）到独立的线程中执行 I/O 操作，操作完成后，会触发侦查员的 completed 或者 failed 方法。</p>

<p>1）Future</p>

<p>先来看一个示例，代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">InterruptedException</span><span class="o">,</span> <span class="nc">ExecutionException</span> <span class="o">{</span>
	<span class="nc">Path</span> <span class="n">file</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"沉默王二.txt"</span><span class="o">);</span>
	<span class="nc">AsynchronousFileChannel</span> <span class="n">channel</span> <span class="o">=</span> <span class="nc">AsynchronousFileChannel</span><span class="o">.</span><span class="na">open</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
	<span class="nc">Future</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="nc">ByteBuffer</span><span class="o">.</span><span class="na">allocate</span><span class="o">(</span><span class="mi">100_000</span><span class="o">),</span> <span class="mi">0</span><span class="o">);</span>
	<span class="k">while</span> <span class="o">(!</span><span class="n">result</span><span class="o">.</span><span class="na">isDone</span><span class="o">())</span> <span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"主线程继续做事情"</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="nc">Integer</span> <span class="n">bytesRead</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">bytesRead</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>1）通过 <code class="highlighter-rouge">AsynchronousFileChannel.open()</code> 打开一个异步文件通道 channel。</p>

<p>2）用 Future 来保存从通道中读取的结果。</p>

<p>3）通过 <code class="highlighter-rouge">isDone()</code> 轮循判断异步 I/O 操作是否完成，如果没有完成的话，主线程可以继续做自己的事情。</p>

<p>2）Callback</p>

<p>先来看一个示例，代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">InterruptedException</span><span class="o">,</span> <span class="nc">ExecutionException</span> <span class="o">{</span>
	<span class="nc">Path</span> <span class="n">file</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"沉默王二.txt"</span><span class="o">);</span>
	<span class="nc">AsynchronousFileChannel</span> <span class="n">channel</span> <span class="o">=</span> <span class="nc">AsynchronousFileChannel</span><span class="o">.</span><span class="na">open</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
	<span class="n">channel</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="nc">ByteBuffer</span><span class="o">.</span><span class="na">allocate</span><span class="o">(</span><span class="mi">100_000</span><span class="o">),</span> <span class="mi">0</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="k">new</span> <span class="nc">CompletionHandler</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">ByteBuffer</span><span class="o">&gt;()</span> <span class="o">{</span>
		<span class="kd">public</span> <span class="kt">void</span> <span class="nf">completed</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">result</span><span class="o">,</span> <span class="nc">ByteBuffer</span> <span class="n">attachment</span><span class="o">)</span> <span class="o">{</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
		<span class="o">}</span>
		
		<span class="kd">public</span> <span class="kt">void</span> <span class="nf">failed</span><span class="o">(</span><span class="nc">Throwable</span> <span class="n">exc</span><span class="o">,</span> <span class="nc">ByteBuffer</span> <span class="n">attachment</span><span class="o">)</span> <span class="o">{</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">exc</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
		<span class="o">}</span>
	<span class="o">});</span>
	
	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"主线程继续做事情"</span><span class="o">);</span>

<span class="o">}</span>
</code></pre></div></div>

<p>1）通过 <code class="highlighter-rouge">AsynchronousFileChannel.open()</code> 打开一个异步文件通道 channel。</p>

<p>2）在 read 方法中使用匿名内部类的形式启用 CompletionHandler，然后实现 CompletionHandler 的两个监听方法，completed 的时候打印结果，failed 的时候打印异常信息。</p>

<p>不管是 Future 形式还是 Callback 形式，总之异步 I/O 是一个强大的特性，可以保证在处理大文件时性能不受到显著的影响。</p>
:ET