# Java 运算符


上回我们分解了Java运算符的前三类*算术运算符*、*关系运算符*、*位运算符*，今天我们就来说剩下的**逻辑运算符**、**赋值运算符**和**其他运算符** 这三类运算符，不多赘述，我们直接入场！

首先我们来分解逻辑运算符。

### 逻辑运算符

#### 定义


逻辑运算符就是用于`处理逻辑值`的运算符

逻辑运算符把*各个运算的关系表达式*连接起来组成一个复杂的逻辑表达式，以*判断程序中的表达式是否成立*，判断的结果是 *true* 或 *false*。

逻辑运算符是对布尔型变量进行运算，其结果也是布尔型

处理的数据：逻辑值；处理的结果：逻辑值



下面列出了逻辑运算符的基本运算用法、含义及实例

#### 普通逻辑运算符

|   操作符  |   含义及描述  |   用法  | 
| --- | --- | --- | 
|  &   |  *逻辑与* - 当且仅当两个操作数都为真，条件才为真 |   A & B  |    
|  \|  |  *逻辑或* - 如果任何两个操作数任何一个为真，条件为真 |   A \| B  |   
|  ^   |  *逻辑异或* - 当且仅当两个操作数具有不同的布尔值时，条件为真   |   A ^ B  | 
|  !   |  *逻辑非* - 用来反转操作数的逻辑状态，如果条件为true，则逻辑非运算符将得到false   |  !A   | 


- *&：逻辑与*   全真为真，否则为假

  `true   &   true` 	 	  true
 	  
  `true   &   false`		  false
 	
  `false  &   true`		    false
 	
  `false  &   false`		  false

- *|：逻辑或*   全假为假，否则为真
 	
  `true   |   true`		  true
 	
  `true   |   false`		true
 	
  `false  |   true`		  true
 	
  `false  |   false`		false
  
- *^：逻辑异或*  相同为假，不同为真
 	
  `true   ^   true`		  false
 	
  `true   ^   false`		true
 	
  `false  ^   true`		  true
 	
  `false  ^   false`		false
  
  
  
- *!：逻辑非*   遇真为假、遇假为真  **常用**
 	
  `!true`		false
 	
  `!false`	true


##### 实例

下面的简单示例程序演示下普通逻辑运算符


```java
public class LuoJi {

    public static void main(String[] args) {

        boolean a = true;
        boolean b = false;

        System.out.println("a & b = " + (a & b));
        System.out.println("a | b = " + (a | b));
        System.out.println("a ^ b = " + (a ^ b));
        System.out.println("!a = " + !a);
    }
    
}
```

##### 运行结果


```java
a & b = false
a | b = true
a ^ b = true
!a = false
```



#### 短路逻辑运算符  ***常用***



|   操作符  |   含义及描述  |   用法  | 
| --- | --- | --- | 
|  &&   |  *逻辑短路与* - 当且仅当两个操作数都为真，条件才为真  |  A && B   |    
|  \|\|   |  *逻辑短路或* - 如果任何两个操作数任何一个为真，条件为真  |  A \|\| B  |   


- *&&：逻辑短路与*

  如果第一个表达式计算结果为 `false` ，那么第二个表达式的值就不计算了，直接给出 `false` 的结果
- ||：逻辑短路或

  如果第一个表达式计算结果为 `true` ，那么第二个表达式的值就不需要计算了，直接给出 `true` 的结果



##### 实例


下面的简单示例程序演示下短路逻辑运算符

```java
public class DuanLuLuoJi {

    public static void main(String[] args) {

        int a = 8;//定义一个变量；
        
        boolean b = (a < 2) && (a++ < 15);
        System.out.println("使用短路逻辑与运算符的结果为 " + b);
        System.out.println("a的结果为 " + a);


        boolean c = (a < 15) || (a++ < 2);
        System.out.println("使用短路逻辑或运算符的结果为 " + c);
        System.out.println("a的结果为 " + a);

    }

}
```


##### 运行结果


```java
使用短路逻辑与运算符的结果为 false
a的结果为 8
使用短路逻辑或运算符的结果为 true
a的结果为 8
```

##### 解析

该程序使用到了 *`短路逻辑与运算符(&&)`* 和 *`短路逻辑或运算符(||)`*，首先判断 `a < 2` 的结果为 `false`，则 `b` 的结果必定是 `false`，所以不再执行第二个操作 `a++ < 15` 的判断，所以 `a` 的值依旧为 `8`;

接下来判断 `a < 15` 的结果为 `true`，则 `b` 的结果必定是 `true`，所以不会再执行第二个操作 `a++ < 2` 的判断，所以 `a` 的值依旧还是为 `8`。


####  区别

*`（ && 与 & ） 和 （ || 与 | ） 的 区别`*

- `&& 与 & 区别`

  如果 a 为 false，则不计算 b（因为不论 b 为何值，结果都为 false）

- `|| 与 | 区别`

  如果 a 为 true，则不计算 b（因为不论 b 为何值，结果都为 true）
  
  - 示例
  

    ```java
      public class QuBie {

          public static void main(String[] args) {
              int a = 10;
              boolean result1 = (a > 100) & (a++ > 5);
              System.out.println("逻辑与的结果 " + result1);
              System.out.println(a);//11，说明第二个表达式计算了


              int b = 10;
              boolean result2 = (b > 100) && (b++ > 5);
              System.out.println("短路逻辑与的结果 " + result2);
              System.out.println(b);//10，说明第二个表达式没有执行


              int c = 10;
              boolean result3 = (c > 5) | (c++ > 100);
              System.out.println("逻辑或的结果 " + result3);
              System.out.println(c);//11，说明第二个表达式执行了

              int d = 10;
              boolean result4 = (d > 5) || (d++ > 100);
              System.out.println("短路逻辑或的结果 " + result4);
              System.out.println(d);//10，说明第二个表达式没有执行
          }
      }
    ```
    
  - 运行结果
  
    
    ```java
      逻辑与的结果 false
      11
      短路逻辑与的结果 false
      10
      逻辑或的结果 true
      11
      短路逻辑或的结果 true
      10
    ```


  

❓为什么说短路逻辑运算符是经常使用的，那可是有原因的，具体原因我们下面分解！

*因为*短路逻辑运算符前后的两个表达式中，第一个表达式计算完成之后，一定可以确定整个逻辑表达式的值，那么就不再计算第二个表达式的值。

短路运算符和非短路运算符的运算规则相同，只不过短路与（&&）和短路或（||）能够采用最优化的计算方式，效率更高，*`所以在实际编程时，应该优先考虑使用短路与和短路或。`*

到这逻辑运算符就分解完了，下面我们来继续分解`赋值运算符`！


### 赋值运算符

#### 定义

赋值运算符就是用于给`变量`或者`常量`进行`赋值`的运算符


赋值运算符的符号为“` = `”，它是双目运算符，*左边*的操作数**必须是变量**，**不能是常量或表达式**


#### 语法

> `变量名称 = 表达式内容`


在 Java 语言中，“`变量名称`”和“`表达式`”内容的类型必须匹配，如果类型不匹配则需要自动转化为对应的类型。

注意⚠️：不要将*赋值运算符*与*相等运算符*“ `==` ”混淆。



`赋值运算符`与`其他运算符` `一起使用`，可以表达多种赋值运算的变异效果。例如，在基本的赋值运算符的基础之上，可以结合`算术运算符`，以及前面分解的`位运算符`，组合成`复合`的`赋值运算符`。

下面我们来分解下Java语言所支持的赋值运算符都有那些：

|  操作符   |   描述  |   实例  |
| --- | --- | --- |
|   =  |   *简单的赋值运算符* -  将右操作数的值赋给左侧操作数 |  c = a + b将把a + b得到的值赋给c   |
|  +=  |   *加和赋值操作符* - 把左操作数和右操作数相加赋值给左操作数  |  b += a等价于b = b + a   |
|  -=  |  *减和赋值操作符* - 把左操作数和右操作数相减赋值给左操作数   |  b -= a等价于b = b - a   |
|  *=   |  *乘和赋值操作符* - 把左操作数和右操作数相乘赋值给左操作数   |  b *= a等价于b = b * a   |
|   /=  |  *除和赋值操作符* - 把左操作数和右操作数相除赋值给左操作数  |   b /= a，b 与 a 同类型时等价于 b = b / a  |
|  %=   |   *取模和赋值操作符* - 把左操作数和右操作数取模后赋值给左操作数  | b ％= a等价于b = b ％ a    |
|  <<=   |   *左移位赋值运算符*  |   a <<= 2等价于a = a << 2  |
|  >>=   |   *右移位赋值运算符*  |   a >>= 2等价于a = a >> 2   |
|  >>>=   |   *右移补零位赋值运算符*  |   a >>>= 2等价于a = a >>> 2   |
|  &=   |   *按位与赋值运算符*  |  a &= 2等价于a = a ＆ 2   |
|  \|=   |   *按位或赋值操作符*  |   a \|= 2等价于a = a \| 2  |
|   ^=  |   *按位异或赋值操作符*  |   a ^= 2等价于a = a ^ 2  |

#### 实例


```java
public class FuZhi {

    public static void main(String[] args) {
        int a = 10;
        int b = 20;
        int c = 0;

        //简单的赋值运算符
        c = a + b;
        System.out.println("c = a + b = " + c);

        //加和赋值操作符
        c += a;
        System.out.println("c += a  = " + c);

        //减和赋值操作符
        c -= a;
        System.out.println("c -= a  = " + c);

        //乘和赋值操作符
        c *= a;
        System.out.println("c *= a  = " + c);

        //除和赋值操作符
        a = 10;
        c = 15;
        c /= a;
        System.out.println("c /= a  = " + c);

        //取模和赋值操作符
        a = 10;
        c = 15;
        c %= a;
        System.out.println("c %= a  = " + c);

        //左移位赋值运算符
        c <<= 2;
        System.out.println("c <<= 2 = " + c);

        //右移位赋值运算符
        c >>= 2;
        System.out.println("c >>= 2 = " + c);

        //右移补零位赋值运算符
        c >>>= 2;
        System.out.println("c >>>= 2 = " + c);

        ////按位与赋值运算符
        c &= a;
        System.out.println("c &= a  = " + c);

        // //按位或赋值操作符
        c |= a;
        System.out.println("c |= a  = " + c);

        ////按位异或赋值操作符
        c ^= a;
        System.out.println("c ^= a  = " + c);

    }
}
```

#### 运行结果



```java
c = a + b = 30
c += a  = 40
c -= a  = 30
c *= a  = 300
c /= a  = 1
c %= a  = 5
c <<= 2 = 20
c >>= 2 = 5
c >>>= 2 = 1
c &= a  = 0
c |= a  = 10
c ^= a  = 0
```


看到这赋值运算符就分解到这里了，接下来到 最后的 **其他运算符**了，那这个其他运算符到底是什么呢？我们继续探分晓！


### 其他运算符

其他运算符我们这里来分解两个运算符，分别是 **条件运算符** 和  **instanceof 运算符** ，下面就来详细分解下这两个运算符！

#### 条件运算符 *（ ? :）*

##### 定义



条件运算符是Java 提供的一个特别运算符，也被称为 *`三元运算符`*。该运算符有 `3`个操作数，并且需要`判断布尔表达式的值`。该运算符的主要是决定哪个值应该赋值给变量。

*同时可以操作三个数据或者表达式的运算符*

##### 语法


```java
variable  x = (expression)  ?  value  if  true  :  value  if  false
```


`expression` 是一个*布尔表达式*。当 `expression` 为*真*时，执行 `value  if  true`的值， 否则就执行 `value  if  false`。此三元运算符要求返回一个结果，因此要实现简单的二分支程序，即可使用该条件运算符。

##### 实例

```java
public class SanYuan {
   public static void main(String[] args){
      int a , b;
      a = 10;
      // 如果 a 等于 1 成立，则设置 b 为 20，否则为 30
      b = (a == 1) ? 20 : 30;
      System.out.println( "Value of b is : " +  b );
 
      // 如果 a 等于 10 成立，则设置 b 为 20，否则为 30
      b = (a == 10) ? 20 : 30;
      System.out.println( "Value of b is : " + b );
   }
}
```

##### 运行结果


```java
Value of b is : 30
Value of b is : 20
```

三元运算符在日常中使用还是比较常见的，用于比较二分支程序，使用起来也相对方便，简单。推荐经常练练！接下来分解今天的最后一个运算符——`instanceof 运算符`

#### instanceof 运算符


instanceof 运算符主要用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。

##### 语法格式


```java
( Object reference variable ) instanceof  (class/interface type)
```




类和接口等等这些，刚入门的小伙伴们肯定还不知道，所以这个我们今天就简单的举个例子，提前了解下就可以，后期等掌握了类和接口等等，再可以回来好好理解一下。此处就不做详细分解了！

##### 实例

**one**

*如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真。*




```java
String name = "ChaoRenZhuanShu";
boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真
```

**two**

*如果被比较的对象兼容于右侧类型,该运算符仍然返回true。*




```java
class People {}
 
public class Teacher extends People {
   public static void main(String[] args){
      People p = new Teacher();
      boolean result =  p instanceof Teacher;
      System.out.println( result);
   }
}
```

运行结果：


```java
true
```

说到这，运算符就全部分解完结了，说到这了我突然想起一个至为重要的事情，

小伙伴们肯定都小时候学过*加减乘除*，它们是有优先级，先乘除后加减，Java运算符也亦如此，它们也有自己的优先级，接下来我们就来好好看看，这可尤为重要，不许眨眼啊！


## 优先级


当多个运算符出现在一个表达式中，到底谁先谁后呢？这就涉及到运算符的优先级别的问题。在一个多运算符的表达式中，运算符优先级不同会导致最后得出的结果差别甚大。

例如：*（1+3）＋（3+2）\*2* ，这个表达式如果按加号最优先计算，答案就是 *18*，如果按照乘号最优先，答案则是 *14*。

再如，*x = 7 + 3 \* 2* ;这里 *x* 得到 13，而不是20，因为乘法运算符比加法运算符有较高的优先级，所以先计算 3 * 2得到 6，然后再加7。

*`下表中具有最高优先级的运算符在的表的最上面，最低优先级的在表的底部`。*

|  类别   |   操作符  |  关联性   |
| --- | --- | --- |
|  后缀   |  () [] . (点操作符)   |   左到右  |
|  一元   |  expr++  expr--   |   从左到右  |
|  一元   |  ++expr --expr + - ～ ！   |   从右到左  |
|  乘性   |  * /％   |   左到右  |
|  加性   |  + -   |  左到右   |
|  移位   |  >> >>>  <<   |   左到右  |
|  关系   |  > >= < <=   |   左到右  |
|  相等   |  ==  !=   |  左到右   |
|  按位与   |  ＆   |   左到右  |
|  按位异或   |  ^   |  左到右   |
|  按位或   |   \|  |   左到右  |
|  逻辑与   |  &&   |  左到右   |
|  逻辑或   |   \|\|   |  左到右   |
|  条件   |   ？：  |   从右到左  |
|  赋值   |  = += -= *= /= ％= >>= <<= ＆= ^= \|=   |   从右到左  |
|  逗号   |   ,  |  左到右   |


以上就是所有Java运算符的优先级，记得要记下来！

## 总结
		
经过两回的分解，Java运算符最终详细解说完了，当你看到这的时候，满脑子都是运算符的时候，那装了这么多知识，还不速速去实践，别等我，先赶紧去操练吧！

